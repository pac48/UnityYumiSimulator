//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.PerformanceTesting;
using Unity.Mathematics.Geometry;
using Unity.Burst;

namespace Unity.Mathematics.PerformanceTests
{
    partial class TestRandom
    {
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextUint
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public uint* u;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    u = (uint*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint>() * 10000, UnsafeUtility.AlignOf<uint>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        u[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(u, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.u[i] = args.rng[i].NextUInt();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextUint_mono()
        {
            Random_NextUint.TestFunction testFunction = Random_NextUint.MonoTestFunction;
            var args = new Random_NextUint.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextUint_burst()
        {
            FunctionPointer<Random_NextUint.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextUint.TestFunction>(Random_NextUint.BurstTestFunction);
            var args = new Random_NextUint.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextUint2
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public uint2* u;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    u = (uint2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint2>() * 10000, UnsafeUtility.AlignOf<uint2>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        u[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(u, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.u[i] = args.rng[i].NextUInt2();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextUint2_mono()
        {
            Random_NextUint2.TestFunction testFunction = Random_NextUint2.MonoTestFunction;
            var args = new Random_NextUint2.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextUint2_burst()
        {
            FunctionPointer<Random_NextUint2.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextUint2.TestFunction>(Random_NextUint2.BurstTestFunction);
            var args = new Random_NextUint2.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextUint3
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public uint3* u;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    u = (uint3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint3>() * 10000, UnsafeUtility.AlignOf<uint3>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        u[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(u, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.u[i] = args.rng[i].NextUInt3();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextUint3_mono()
        {
            Random_NextUint3.TestFunction testFunction = Random_NextUint3.MonoTestFunction;
            var args = new Random_NextUint3.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextUint3_burst()
        {
            FunctionPointer<Random_NextUint3.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextUint3.TestFunction>(Random_NextUint3.BurstTestFunction);
            var args = new Random_NextUint3.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextUint4
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public uint4* u;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    u = (uint4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<uint4>() * 10000, UnsafeUtility.AlignOf<uint4>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        u[i] = 0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(u, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.u[i] = args.rng[i].NextUInt4();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextUint4_mono()
        {
            Random_NextUint4.TestFunction testFunction = Random_NextUint4.MonoTestFunction;
            var args = new Random_NextUint4.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextUint4_burst()
        {
            FunctionPointer<Random_NextUint4.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextUint4.TestFunction>(Random_NextUint4.BurstTestFunction);
            var args = new Random_NextUint4.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextFloat
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public float* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (float*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float>() * 10000, UnsafeUtility.AlignOf<float>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = 0.0f;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextFloat();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextFloat_mono()
        {
            Random_NextFloat.TestFunction testFunction = Random_NextFloat.MonoTestFunction;
            var args = new Random_NextFloat.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextFloat_burst()
        {
            FunctionPointer<Random_NextFloat.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextFloat.TestFunction>(Random_NextFloat.BurstTestFunction);
            var args = new Random_NextFloat.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextFloat2
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public float2* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (float2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float2>() * 10000, UnsafeUtility.AlignOf<float2>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = new float2(0.0f);
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextFloat2();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextFloat2_mono()
        {
            Random_NextFloat2.TestFunction testFunction = Random_NextFloat2.MonoTestFunction;
            var args = new Random_NextFloat2.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextFloat2_burst()
        {
            FunctionPointer<Random_NextFloat2.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextFloat2.TestFunction>(Random_NextFloat2.BurstTestFunction);
            var args = new Random_NextFloat2.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextFloat3
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public float3* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (float3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float3>() * 10000, UnsafeUtility.AlignOf<float3>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = new float3(0.0f);
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextFloat3();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextFloat3_mono()
        {
            Random_NextFloat3.TestFunction testFunction = Random_NextFloat3.MonoTestFunction;
            var args = new Random_NextFloat3.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextFloat3_burst()
        {
            FunctionPointer<Random_NextFloat3.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextFloat3.TestFunction>(Random_NextFloat3.BurstTestFunction);
            var args = new Random_NextFloat3.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextFloat4
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public float4* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (float4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<float4>() * 10000, UnsafeUtility.AlignOf<float4>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = new float4(0.0f);
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextFloat4();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextFloat4_mono()
        {
            Random_NextFloat4.TestFunction testFunction = Random_NextFloat4.MonoTestFunction;
            var args = new Random_NextFloat4.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextFloat4_burst()
        {
            FunctionPointer<Random_NextFloat4.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextFloat4.TestFunction>(Random_NextFloat4.BurstTestFunction);
            var args = new Random_NextFloat4.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextDouble
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public double* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (double*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double>() * 10000, UnsafeUtility.AlignOf<double>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = 0.0;
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextDouble();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextDouble_mono()
        {
            Random_NextDouble.TestFunction testFunction = Random_NextDouble.MonoTestFunction;
            var args = new Random_NextDouble.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextDouble_burst()
        {
            FunctionPointer<Random_NextDouble.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextDouble.TestFunction>(Random_NextDouble.BurstTestFunction);
            var args = new Random_NextDouble.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextDouble2
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public double2* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (double2*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double2>() * 10000, UnsafeUtility.AlignOf<double2>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = new double2(0.0);
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextDouble2();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextDouble2_mono()
        {
            Random_NextDouble2.TestFunction testFunction = Random_NextDouble2.MonoTestFunction;
            var args = new Random_NextDouble2.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextDouble2_burst()
        {
            FunctionPointer<Random_NextDouble2.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextDouble2.TestFunction>(Random_NextDouble2.BurstTestFunction);
            var args = new Random_NextDouble2.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextDouble3
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public double3* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (double3*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double3>() * 10000, UnsafeUtility.AlignOf<double3>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = new double3(0.0);
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextDouble3();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextDouble3_mono()
        {
            Random_NextDouble3.TestFunction testFunction = Random_NextDouble3.MonoTestFunction;
            var args = new Random_NextDouble3.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextDouble3_burst()
        {
            FunctionPointer<Random_NextDouble3.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextDouble3.TestFunction>(Random_NextDouble3.BurstTestFunction);
            var args = new Random_NextDouble3.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
        [BurstCompile(CompileSynchronously = true)]
        public unsafe class Random_NextDouble4
        {
            public struct Arguments : IDisposable
            {
                public Random* rng;
                public double4* f;

                public void Init()
                {
                    rng = (Random*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<Random>() * 10000, UnsafeUtility.AlignOf<Random>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        rng[i] = new Unity.Mathematics.Random(1);
                    }

                    f = (double4*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<double4>() * 10000, UnsafeUtility.AlignOf<double4>(), Allocator.Persistent);
                    for (int i = 0; i < 10000; ++i)
                    {
                        f[i] = new double4(0.0);
                    }

                }

                public void Dispose()
                {
                    UnsafeUtility.Free(rng, Allocator.Persistent);
                    UnsafeUtility.Free(f, Allocator.Persistent);
                }
            }

            public static void CommonTestFunction(ref Arguments args)
            {
                for (int i = 0; i < 10000; ++i)
                {
                    args.f[i] = args.rng[i].NextDouble4();
                }
            }

            public static void MonoTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            [BurstCompile(CompileSynchronously = true)]
            public static void BurstTestFunction(ref Arguments args)
            {
                CommonTestFunction(ref args);
            }

            public delegate void TestFunction(ref Arguments args);
        }

        [Test, Performance]
        public void Random_NextDouble4_mono()
        {
            Random_NextDouble4.TestFunction testFunction = Random_NextDouble4.MonoTestFunction;
            var args = new Random_NextDouble4.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }

        [Test, Performance]
        public void Random_NextDouble4_burst()
        {
            FunctionPointer<Random_NextDouble4.TestFunction> testFunction = BurstCompiler.CompileFunctionPointer<Random_NextDouble4.TestFunction>(Random_NextDouble4.BurstTestFunction);
            var args = new Random_NextDouble4.Arguments();
            args.Init();

            Measure.Method(() =>
            {
                testFunction.Invoke(ref args);
            })
            .Definition(sampleUnit: SampleUnit.Microsecond)
            .WarmupCount(1)
            .MeasurementCount(10)
            .Run();
            args.Dispose();
        }
    }
}
