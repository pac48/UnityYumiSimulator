// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper_trajectory.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "egm_wrapper_trajectory.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace abb {
namespace egm {
namespace wrapper {
namespace trajectory {

namespace {

const ::google::protobuf::Descriptor* JointGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JointGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* CartesianGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CartesianGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExternalGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExternalGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* PointGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PointGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotPositionGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotPositionGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotVelocityGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotVelocityGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrajectoryGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrajectoryGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* StaticPositionGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StaticPositionGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* StaticVelocityGoal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StaticVelocityGoal_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutionProgress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutionProgress_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ExecutionProgress_State_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ExecutionProgress_SubState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_egm_5fwrapper_5ftrajectory_2eproto() {
  protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "egm_wrapper_trajectory.proto");
  GOOGLE_CHECK(file != NULL);
  JointGoal_descriptor_ = file->message_type(0);
  static const int JointGoal_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointGoal, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointGoal, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointGoal, acceleration_),
  };
  JointGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JointGoal_descriptor_,
      JointGoal::default_instance_,
      JointGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JointGoal));
  CartesianGoal_descriptor_ = file->message_type(1);
  static const int CartesianGoal_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianGoal, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianGoal, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianGoal, acceleration_),
  };
  CartesianGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CartesianGoal_descriptor_,
      CartesianGoal::default_instance_,
      CartesianGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CartesianGoal));
  RobotGoal_descriptor_ = file->message_type(2);
  static const int RobotGoal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotGoal, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotGoal, cartesian_),
  };
  RobotGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotGoal_descriptor_,
      RobotGoal::default_instance_,
      RobotGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotGoal));
  ExternalGoal_descriptor_ = file->message_type(3);
  static const int ExternalGoal_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExternalGoal, joints_),
  };
  ExternalGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExternalGoal_descriptor_,
      ExternalGoal::default_instance_,
      ExternalGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExternalGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExternalGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExternalGoal));
  PointGoal_descriptor_ = file->message_type(4);
  static const int PointGoal_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointGoal, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointGoal, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointGoal, external_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointGoal, reach_),
  };
  PointGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PointGoal_descriptor_,
      PointGoal::default_instance_,
      PointGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PointGoal));
  RobotPositionGoal_descriptor_ = file->message_type(5);
  static const int RobotPositionGoal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPositionGoal, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPositionGoal, cartesian_),
  };
  RobotPositionGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotPositionGoal_descriptor_,
      RobotPositionGoal::default_instance_,
      RobotPositionGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPositionGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPositionGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotPositionGoal));
  RobotVelocityGoal_descriptor_ = file->message_type(6);
  static const int RobotVelocityGoal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocityGoal, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocityGoal, cartesian_),
  };
  RobotVelocityGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotVelocityGoal_descriptor_,
      RobotVelocityGoal::default_instance_,
      RobotVelocityGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocityGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocityGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotVelocityGoal));
  TrajectoryGoal_descriptor_ = file->message_type(7);
  static const int TrajectoryGoal_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrajectoryGoal, points_),
  };
  TrajectoryGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TrajectoryGoal_descriptor_,
      TrajectoryGoal::default_instance_,
      TrajectoryGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrajectoryGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrajectoryGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TrajectoryGoal));
  StaticPositionGoal_descriptor_ = file->message_type(8);
  static const int StaticPositionGoal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticPositionGoal, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticPositionGoal, external_),
  };
  StaticPositionGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StaticPositionGoal_descriptor_,
      StaticPositionGoal::default_instance_,
      StaticPositionGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticPositionGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticPositionGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StaticPositionGoal));
  StaticVelocityGoal_descriptor_ = file->message_type(9);
  static const int StaticVelocityGoal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticVelocityGoal, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticVelocityGoal, external_),
  };
  StaticVelocityGoal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StaticVelocityGoal_descriptor_,
      StaticVelocityGoal::default_instance_,
      StaticVelocityGoal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticVelocityGoal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaticVelocityGoal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StaticVelocityGoal));
  ExecutionProgress_descriptor_ = file->message_type(10);
  static const int ExecutionProgress_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, sub_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, time_passed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, goal_active_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, goal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, active_trajectory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, pending_trajectories_),
  };
  ExecutionProgress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutionProgress_descriptor_,
      ExecutionProgress::default_instance_,
      ExecutionProgress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionProgress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutionProgress));
  ExecutionProgress_State_descriptor_ = ExecutionProgress_descriptor_->enum_type(0);
  ExecutionProgress_SubState_descriptor_ = ExecutionProgress_descriptor_->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_egm_5fwrapper_5ftrajectory_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JointGoal_descriptor_, &JointGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CartesianGoal_descriptor_, &CartesianGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotGoal_descriptor_, &RobotGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExternalGoal_descriptor_, &ExternalGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PointGoal_descriptor_, &PointGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotPositionGoal_descriptor_, &RobotPositionGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotVelocityGoal_descriptor_, &RobotVelocityGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TrajectoryGoal_descriptor_, &TrajectoryGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StaticPositionGoal_descriptor_, &StaticPositionGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StaticVelocityGoal_descriptor_, &StaticVelocityGoal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutionProgress_descriptor_, &ExecutionProgress::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_egm_5fwrapper_5ftrajectory_2eproto() {
  delete JointGoal::default_instance_;
  delete JointGoal_reflection_;
  delete CartesianGoal::default_instance_;
  delete CartesianGoal_reflection_;
  delete RobotGoal::default_instance_;
  delete RobotGoal_reflection_;
  delete ExternalGoal::default_instance_;
  delete ExternalGoal_reflection_;
  delete PointGoal::default_instance_;
  delete PointGoal_reflection_;
  delete RobotPositionGoal::default_instance_;
  delete RobotPositionGoal_reflection_;
  delete RobotVelocityGoal::default_instance_;
  delete RobotVelocityGoal_reflection_;
  delete TrajectoryGoal::default_instance_;
  delete TrajectoryGoal_reflection_;
  delete StaticPositionGoal::default_instance_;
  delete StaticPositionGoal_reflection_;
  delete StaticVelocityGoal::default_instance_;
  delete StaticVelocityGoal_reflection_;
  delete ExecutionProgress::default_instance_;
  delete ExecutionProgress_reflection_;
}

void protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::abb::egm::wrapper::protobuf_AddDesc_egm_5fwrapper_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\034egm_wrapper_trajectory.proto\022\032abb.egm."
    "wrapper.trajectory\032\021egm_wrapper.proto\"\220\001"
    "\n\tJointGoal\022)\n\010position\030\001 \001(\0132\027.abb.egm."
    "wrapper.Joints\022)\n\010velocity\030\002 \001(\0132\027.abb.e"
    "gm.wrapper.Joints\022-\n\014acceleration\030\003 \001(\0132"
    "\027.abb.egm.wrapper.Joints\"\235\001\n\rCartesianGo"
    "al\022,\n\004pose\030\001 \001(\0132\036.abb.egm.wrapper.Carte"
    "sianPose\022,\n\010velocity\030\002 \001(\0132\032.abb.egm.wra"
    "pper.Cartesian\0220\n\014acceleration\030\003 \001(\0132\032.a"
    "bb.egm.wrapper.Cartesian\"\200\001\n\tRobotGoal\0225"
    "\n\006joints\030\001 \001(\0132%.abb.egm.wrapper.traject"
    "ory.JointGoal\022<\n\tcartesian\030\002 \001(\0132).abb.e"
    "gm.wrapper.trajectory.CartesianGoal\"E\n\014E"
    "xternalGoal\0225\n\006joints\030\001 \001(\0132%.abb.egm.wr"
    "apper.trajectory.JointGoal\"\236\001\n\tPointGoal"
    "\022\020\n\010duration\030\001 \001(\001\0224\n\005robot\030\002 \001(\0132%.abb."
    "egm.wrapper.trajectory.RobotGoal\022:\n\010exte"
    "rnal\030\003 \001(\0132(.abb.egm.wrapper.trajectory."
    "ExternalGoal\022\r\n\005reach\030\004 \001(\010\"o\n\021RobotPosi"
    "tionGoal\022\'\n\006joints\030\001 \001(\0132\027.abb.egm.wrapp"
    "er.Joints\0221\n\tcartesian\030\002 \001(\0132\036.abb.egm.w"
    "rapper.CartesianPose\"s\n\021RobotVelocityGoa"
    "l\022\'\n\006joints\030\001 \001(\0132\027.abb.egm.wrapper.Join"
    "ts\0225\n\tcartesian\030\002 \001(\0132\".abb.egm.wrapper."
    "CartesianVelocity\"G\n\016TrajectoryGoal\0225\n\006p"
    "oints\030\001 \003(\0132%.abb.egm.wrapper.trajectory"
    ".PointGoal\"}\n\022StaticPositionGoal\022<\n\005robo"
    "t\030\001 \001(\0132-.abb.egm.wrapper.trajectory.Rob"
    "otPositionGoal\022)\n\010external\030\002 \001(\0132\027.abb.e"
    "gm.wrapper.Joints\"}\n\022StaticVelocityGoal\022"
    "<\n\005robot\030\001 \001(\0132-.abb.egm.wrapper.traject"
    "ory.RobotVelocityGoal\022)\n\010external\030\002 \001(\0132"
    "\027.abb.egm.wrapper.Joints\"\276\004\n\021ExecutionPr"
    "ogress\022M\n\005state\030\001 \001(\01623.abb.egm.wrapper."
    "trajectory.ExecutionProgress.State:\tUNDE"
    "FINED\022O\n\tsub_state\030\002 \001(\01626.abb.egm.wrapp"
    "er.trajectory.ExecutionProgress.SubState"
    ":\004NONE\022&\n\006inputs\030\003 \001(\0132\026.abb.egm.wrapper"
    ".Input\022(\n\007outputs\030\004 \001(\0132\027.abb.egm.wrappe"
    "r.Output\022\023\n\013time_passed\030\005 \001(\001\022\023\n\013goal_ac"
    "tive\030\006 \001(\010\0223\n\004goal\030\007 \001(\0132%.abb.egm.wrapp"
    "er.trajectory.PointGoal\022E\n\021active_trajec"
    "tory\030\010 \001(\0132*.abb.egm.wrapper.trajectory."
    "TrajectoryGoal\022\034\n\024pending_trajectories\030\t"
    " \001(\r\"B\n\005State\022\r\n\tUNDEFINED\020\000\022\n\n\006NORMAL\020\001"
    "\022\r\n\tRAMP_DOWN\020\002\022\017\n\013STATIC_GOAL\020\003\"/\n\010SubS"
    "tate\022\010\n\004NONE\020\000\022\013\n\007RUNNING\020\001\022\014\n\010FINISHED\020"
    "\002", 1881);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "egm_wrapper_trajectory.proto", &protobuf_RegisterTypes);
  JointGoal::default_instance_ = new JointGoal();
  CartesianGoal::default_instance_ = new CartesianGoal();
  RobotGoal::default_instance_ = new RobotGoal();
  ExternalGoal::default_instance_ = new ExternalGoal();
  PointGoal::default_instance_ = new PointGoal();
  RobotPositionGoal::default_instance_ = new RobotPositionGoal();
  RobotVelocityGoal::default_instance_ = new RobotVelocityGoal();
  TrajectoryGoal::default_instance_ = new TrajectoryGoal();
  StaticPositionGoal::default_instance_ = new StaticPositionGoal();
  StaticVelocityGoal::default_instance_ = new StaticVelocityGoal();
  ExecutionProgress::default_instance_ = new ExecutionProgress();
  JointGoal::default_instance_->InitAsDefaultInstance();
  CartesianGoal::default_instance_->InitAsDefaultInstance();
  RobotGoal::default_instance_->InitAsDefaultInstance();
  ExternalGoal::default_instance_->InitAsDefaultInstance();
  PointGoal::default_instance_->InitAsDefaultInstance();
  RobotPositionGoal::default_instance_->InitAsDefaultInstance();
  RobotVelocityGoal::default_instance_->InitAsDefaultInstance();
  TrajectoryGoal::default_instance_->InitAsDefaultInstance();
  StaticPositionGoal::default_instance_->InitAsDefaultInstance();
  StaticVelocityGoal::default_instance_->InitAsDefaultInstance();
  ExecutionProgress::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_egm_5fwrapper_5ftrajectory_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_egm_5fwrapper_5ftrajectory_2eproto {
  StaticDescriptorInitializer_egm_5fwrapper_5ftrajectory_2eproto() {
    protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  }
} static_descriptor_initializer_egm_5fwrapper_5ftrajectory_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int JointGoal::kPositionFieldNumber;
const int JointGoal::kVelocityFieldNumber;
const int JointGoal::kAccelerationFieldNumber;
#endif  // !_MSC_VER

JointGoal::JointGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.JointGoal)
}

void JointGoal::InitAsDefaultInstance() {
  position_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
  velocity_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
  acceleration_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
}

JointGoal::JointGoal(const JointGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.JointGoal)
}

void JointGoal::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  velocity_ = NULL;
  acceleration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JointGoal::~JointGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.JointGoal)
  SharedDtor();
}

void JointGoal::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete velocity_;
    delete acceleration_;
  }
}

void JointGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JointGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JointGoal_descriptor_;
}

const JointGoal& JointGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

JointGoal* JointGoal::default_instance_ = NULL;

JointGoal* JointGoal::New() const {
  return new JointGoal;
}

void JointGoal::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_position()) {
      if (position_ != NULL) position_->::abb::egm::wrapper::Joints::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::abb::egm::wrapper::Joints::Clear();
    }
    if (has_acceleration()) {
      if (acceleration_ != NULL) acceleration_->::abb::egm::wrapper::Joints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JointGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.JointGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_velocity;
        break;
      }

      // optional .abb.egm.wrapper.Joints velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_acceleration;
        break;
      }

      // optional .abb.egm.wrapper.Joints acceleration = 3;
      case 3: {
        if (tag == 26) {
         parse_acceleration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_acceleration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.JointGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.JointGoal)
  return false;
#undef DO_
}

void JointGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.JointGoal)
  // optional .abb.egm.wrapper.Joints position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->position(), output);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->velocity(), output);
  }

  // optional .abb.egm.wrapper.Joints acceleration = 3;
  if (has_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->acceleration(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.JointGoal)
}

::google::protobuf::uint8* JointGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.JointGoal)
  // optional .abb.egm.wrapper.Joints position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->position(), target);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->velocity(), target);
  }

  // optional .abb.egm.wrapper.Joints acceleration = 3;
  if (has_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->acceleration(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.JointGoal)
  return target;
}

int JointGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Joints position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // optional .abb.egm.wrapper.Joints velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity());
    }

    // optional .abb.egm.wrapper.Joints acceleration = 3;
    if (has_acceleration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->acceleration());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JointGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JointGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JointGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JointGoal::MergeFrom(const JointGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::abb::egm::wrapper::Joints::MergeFrom(from.position());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::abb::egm::wrapper::Joints::MergeFrom(from.velocity());
    }
    if (from.has_acceleration()) {
      mutable_acceleration()->::abb::egm::wrapper::Joints::MergeFrom(from.acceleration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JointGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointGoal::CopyFrom(const JointGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointGoal::IsInitialized() const {

  return true;
}

void JointGoal::Swap(JointGoal* other) {
  if (other != this) {
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    std::swap(acceleration_, other->acceleration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JointGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JointGoal_descriptor_;
  metadata.reflection = JointGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CartesianGoal::kPoseFieldNumber;
const int CartesianGoal::kVelocityFieldNumber;
const int CartesianGoal::kAccelerationFieldNumber;
#endif  // !_MSC_VER

CartesianGoal::CartesianGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.CartesianGoal)
}

void CartesianGoal::InitAsDefaultInstance() {
  pose_ = const_cast< ::abb::egm::wrapper::CartesianPose*>(&::abb::egm::wrapper::CartesianPose::default_instance());
  velocity_ = const_cast< ::abb::egm::wrapper::Cartesian*>(&::abb::egm::wrapper::Cartesian::default_instance());
  acceleration_ = const_cast< ::abb::egm::wrapper::Cartesian*>(&::abb::egm::wrapper::Cartesian::default_instance());
}

CartesianGoal::CartesianGoal(const CartesianGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.CartesianGoal)
}

void CartesianGoal::SharedCtor() {
  _cached_size_ = 0;
  pose_ = NULL;
  velocity_ = NULL;
  acceleration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CartesianGoal::~CartesianGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.CartesianGoal)
  SharedDtor();
}

void CartesianGoal::SharedDtor() {
  if (this != default_instance_) {
    delete pose_;
    delete velocity_;
    delete acceleration_;
  }
}

void CartesianGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartesianGoal_descriptor_;
}

const CartesianGoal& CartesianGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

CartesianGoal* CartesianGoal::default_instance_ = NULL;

CartesianGoal* CartesianGoal::New() const {
  return new CartesianGoal;
}

void CartesianGoal::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_pose()) {
      if (pose_ != NULL) pose_->::abb::egm::wrapper::CartesianPose::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::abb::egm::wrapper::Cartesian::Clear();
    }
    if (has_acceleration()) {
      if (acceleration_ != NULL) acceleration_->::abb::egm::wrapper::Cartesian::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CartesianGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.CartesianGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.CartesianPose pose = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_velocity;
        break;
      }

      // optional .abb.egm.wrapper.Cartesian velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_acceleration;
        break;
      }

      // optional .abb.egm.wrapper.Cartesian acceleration = 3;
      case 3: {
        if (tag == 26) {
         parse_acceleration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_acceleration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.CartesianGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.CartesianGoal)
  return false;
#undef DO_
}

void CartesianGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.CartesianGoal)
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pose(), output);
  }

  // optional .abb.egm.wrapper.Cartesian velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->velocity(), output);
  }

  // optional .abb.egm.wrapper.Cartesian acceleration = 3;
  if (has_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->acceleration(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.CartesianGoal)
}

::google::protobuf::uint8* CartesianGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.CartesianGoal)
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pose(), target);
  }

  // optional .abb.egm.wrapper.Cartesian velocity = 2;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->velocity(), target);
  }

  // optional .abb.egm.wrapper.Cartesian acceleration = 3;
  if (has_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->acceleration(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.CartesianGoal)
  return target;
}

int CartesianGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.CartesianPose pose = 1;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pose());
    }

    // optional .abb.egm.wrapper.Cartesian velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity());
    }

    // optional .abb.egm.wrapper.Cartesian acceleration = 3;
    if (has_acceleration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->acceleration());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CartesianGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CartesianGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CartesianGoal::MergeFrom(const CartesianGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pose()) {
      mutable_pose()->::abb::egm::wrapper::CartesianPose::MergeFrom(from.pose());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::abb::egm::wrapper::Cartesian::MergeFrom(from.velocity());
    }
    if (from.has_acceleration()) {
      mutable_acceleration()->::abb::egm::wrapper::Cartesian::MergeFrom(from.acceleration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CartesianGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianGoal::CopyFrom(const CartesianGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianGoal::IsInitialized() const {

  return true;
}

void CartesianGoal::Swap(CartesianGoal* other) {
  if (other != this) {
    std::swap(pose_, other->pose_);
    std::swap(velocity_, other->velocity_);
    std::swap(acceleration_, other->acceleration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CartesianGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CartesianGoal_descriptor_;
  metadata.reflection = CartesianGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotGoal::kJointsFieldNumber;
const int RobotGoal::kCartesianFieldNumber;
#endif  // !_MSC_VER

RobotGoal::RobotGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.RobotGoal)
}

void RobotGoal::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::wrapper::trajectory::JointGoal*>(&::abb::egm::wrapper::trajectory::JointGoal::default_instance());
  cartesian_ = const_cast< ::abb::egm::wrapper::trajectory::CartesianGoal*>(&::abb::egm::wrapper::trajectory::CartesianGoal::default_instance());
}

RobotGoal::RobotGoal(const RobotGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.RobotGoal)
}

void RobotGoal::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesian_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotGoal::~RobotGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.RobotGoal)
  SharedDtor();
}

void RobotGoal::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesian_;
  }
}

void RobotGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotGoal_descriptor_;
}

const RobotGoal& RobotGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

RobotGoal* RobotGoal::default_instance_ = NULL;

RobotGoal* RobotGoal::New() const {
  return new RobotGoal;
}

void RobotGoal::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::wrapper::trajectory::JointGoal::Clear();
    }
    if (has_cartesian()) {
      if (cartesian_ != NULL) cartesian_->::abb::egm::wrapper::trajectory::CartesianGoal::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.RobotGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesian;
        break;
      }

      // optional .abb.egm.wrapper.trajectory.CartesianGoal cartesian = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.RobotGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.RobotGoal)
  return false;
#undef DO_
}

void RobotGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.RobotGoal)
  // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.wrapper.trajectory.CartesianGoal cartesian = 2;
  if (has_cartesian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesian(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.RobotGoal)
}

::google::protobuf::uint8* RobotGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.RobotGoal)
  // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.wrapper.trajectory.CartesianGoal cartesian = 2;
  if (has_cartesian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesian(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.RobotGoal)
  return target;
}

int RobotGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.wrapper.trajectory.CartesianGoal cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesian());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotGoal::MergeFrom(const RobotGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::wrapper::trajectory::JointGoal::MergeFrom(from.joints());
    }
    if (from.has_cartesian()) {
      mutable_cartesian()->::abb::egm::wrapper::trajectory::CartesianGoal::MergeFrom(from.cartesian());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotGoal::CopyFrom(const RobotGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotGoal::IsInitialized() const {

  return true;
}

void RobotGoal::Swap(RobotGoal* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesian_, other->cartesian_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotGoal_descriptor_;
  metadata.reflection = RobotGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExternalGoal::kJointsFieldNumber;
#endif  // !_MSC_VER

ExternalGoal::ExternalGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.ExternalGoal)
}

void ExternalGoal::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::wrapper::trajectory::JointGoal*>(&::abb::egm::wrapper::trajectory::JointGoal::default_instance());
}

ExternalGoal::ExternalGoal(const ExternalGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.ExternalGoal)
}

void ExternalGoal::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExternalGoal::~ExternalGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.ExternalGoal)
  SharedDtor();
}

void ExternalGoal::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
  }
}

void ExternalGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExternalGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExternalGoal_descriptor_;
}

const ExternalGoal& ExternalGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

ExternalGoal* ExternalGoal::default_instance_ = NULL;

ExternalGoal* ExternalGoal::New() const {
  return new ExternalGoal;
}

void ExternalGoal::Clear() {
  if (has_joints()) {
    if (joints_ != NULL) joints_->::abb::egm::wrapper::trajectory::JointGoal::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExternalGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.ExternalGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.ExternalGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.ExternalGoal)
  return false;
#undef DO_
}

void ExternalGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.ExternalGoal)
  // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.ExternalGoal)
}

::google::protobuf::uint8* ExternalGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.ExternalGoal)
  // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.ExternalGoal)
  return target;
}

int ExternalGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.trajectory.JointGoal joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExternalGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExternalGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExternalGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExternalGoal::MergeFrom(const ExternalGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::wrapper::trajectory::JointGoal::MergeFrom(from.joints());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExternalGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExternalGoal::CopyFrom(const ExternalGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalGoal::IsInitialized() const {

  return true;
}

void ExternalGoal::Swap(ExternalGoal* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExternalGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExternalGoal_descriptor_;
  metadata.reflection = ExternalGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PointGoal::kDurationFieldNumber;
const int PointGoal::kRobotFieldNumber;
const int PointGoal::kExternalFieldNumber;
const int PointGoal::kReachFieldNumber;
#endif  // !_MSC_VER

PointGoal::PointGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.PointGoal)
}

void PointGoal::InitAsDefaultInstance() {
  robot_ = const_cast< ::abb::egm::wrapper::trajectory::RobotGoal*>(&::abb::egm::wrapper::trajectory::RobotGoal::default_instance());
  external_ = const_cast< ::abb::egm::wrapper::trajectory::ExternalGoal*>(&::abb::egm::wrapper::trajectory::ExternalGoal::default_instance());
}

PointGoal::PointGoal(const PointGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.PointGoal)
}

void PointGoal::SharedCtor() {
  _cached_size_ = 0;
  duration_ = 0;
  robot_ = NULL;
  external_ = NULL;
  reach_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PointGoal::~PointGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.PointGoal)
  SharedDtor();
}

void PointGoal::SharedDtor() {
  if (this != default_instance_) {
    delete robot_;
    delete external_;
  }
}

void PointGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PointGoal_descriptor_;
}

const PointGoal& PointGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

PointGoal* PointGoal::default_instance_ = NULL;

PointGoal* PointGoal::New() const {
  return new PointGoal;
}

void PointGoal::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    duration_ = 0;
    if (has_robot()) {
      if (robot_ != NULL) robot_->::abb::egm::wrapper::trajectory::RobotGoal::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::abb::egm::wrapper::trajectory::ExternalGoal::Clear();
    }
    reach_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PointGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.PointGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double duration = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_robot;
        break;
      }

      // optional .abb.egm.wrapper.trajectory.RobotGoal robot = 2;
      case 2: {
        if (tag == 18) {
         parse_robot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_external;
        break;
      }

      // optional .abb.egm.wrapper.trajectory.ExternalGoal external = 3;
      case 3: {
        if (tag == 26) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_reach;
        break;
      }

      // optional bool reach = 4;
      case 4: {
        if (tag == 32) {
         parse_reach:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reach_)));
          set_has_reach();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.PointGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.PointGoal)
  return false;
#undef DO_
}

void PointGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.PointGoal)
  // optional double duration = 1;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->duration(), output);
  }

  // optional .abb.egm.wrapper.trajectory.RobotGoal robot = 2;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->robot(), output);
  }

  // optional .abb.egm.wrapper.trajectory.ExternalGoal external = 3;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->external(), output);
  }

  // optional bool reach = 4;
  if (has_reach()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->reach(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.PointGoal)
}

::google::protobuf::uint8* PointGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.PointGoal)
  // optional double duration = 1;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->duration(), target);
  }

  // optional .abb.egm.wrapper.trajectory.RobotGoal robot = 2;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->robot(), target);
  }

  // optional .abb.egm.wrapper.trajectory.ExternalGoal external = 3;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->external(), target);
  }

  // optional bool reach = 4;
  if (has_reach()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->reach(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.PointGoal)
  return target;
}

int PointGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double duration = 1;
    if (has_duration()) {
      total_size += 1 + 8;
    }

    // optional .abb.egm.wrapper.trajectory.RobotGoal robot = 2;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot());
    }

    // optional .abb.egm.wrapper.trajectory.ExternalGoal external = 3;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

    // optional bool reach = 4;
    if (has_reach()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PointGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PointGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PointGoal::MergeFrom(const PointGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_robot()) {
      mutable_robot()->::abb::egm::wrapper::trajectory::RobotGoal::MergeFrom(from.robot());
    }
    if (from.has_external()) {
      mutable_external()->::abb::egm::wrapper::trajectory::ExternalGoal::MergeFrom(from.external());
    }
    if (from.has_reach()) {
      set_reach(from.reach());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PointGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointGoal::CopyFrom(const PointGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointGoal::IsInitialized() const {

  return true;
}

void PointGoal::Swap(PointGoal* other) {
  if (other != this) {
    std::swap(duration_, other->duration_);
    std::swap(robot_, other->robot_);
    std::swap(external_, other->external_);
    std::swap(reach_, other->reach_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PointGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PointGoal_descriptor_;
  metadata.reflection = PointGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotPositionGoal::kJointsFieldNumber;
const int RobotPositionGoal::kCartesianFieldNumber;
#endif  // !_MSC_VER

RobotPositionGoal::RobotPositionGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.RobotPositionGoal)
}

void RobotPositionGoal::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
  cartesian_ = const_cast< ::abb::egm::wrapper::CartesianPose*>(&::abb::egm::wrapper::CartesianPose::default_instance());
}

RobotPositionGoal::RobotPositionGoal(const RobotPositionGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.RobotPositionGoal)
}

void RobotPositionGoal::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesian_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotPositionGoal::~RobotPositionGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.RobotPositionGoal)
  SharedDtor();
}

void RobotPositionGoal::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesian_;
  }
}

void RobotPositionGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotPositionGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotPositionGoal_descriptor_;
}

const RobotPositionGoal& RobotPositionGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

RobotPositionGoal* RobotPositionGoal::default_instance_ = NULL;

RobotPositionGoal* RobotPositionGoal::New() const {
  return new RobotPositionGoal;
}

void RobotPositionGoal::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::wrapper::Joints::Clear();
    }
    if (has_cartesian()) {
      if (cartesian_ != NULL) cartesian_->::abb::egm::wrapper::CartesianPose::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotPositionGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.RobotPositionGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesian;
        break;
      }

      // optional .abb.egm.wrapper.CartesianPose cartesian = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.RobotPositionGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.RobotPositionGoal)
  return false;
#undef DO_
}

void RobotPositionGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.RobotPositionGoal)
  // optional .abb.egm.wrapper.Joints joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.wrapper.CartesianPose cartesian = 2;
  if (has_cartesian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesian(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.RobotPositionGoal)
}

::google::protobuf::uint8* RobotPositionGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.RobotPositionGoal)
  // optional .abb.egm.wrapper.Joints joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.wrapper.CartesianPose cartesian = 2;
  if (has_cartesian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesian(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.RobotPositionGoal)
  return target;
}

int RobotPositionGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Joints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.wrapper.CartesianPose cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesian());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotPositionGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotPositionGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotPositionGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotPositionGoal::MergeFrom(const RobotPositionGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::wrapper::Joints::MergeFrom(from.joints());
    }
    if (from.has_cartesian()) {
      mutable_cartesian()->::abb::egm::wrapper::CartesianPose::MergeFrom(from.cartesian());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotPositionGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotPositionGoal::CopyFrom(const RobotPositionGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotPositionGoal::IsInitialized() const {

  return true;
}

void RobotPositionGoal::Swap(RobotPositionGoal* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesian_, other->cartesian_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotPositionGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotPositionGoal_descriptor_;
  metadata.reflection = RobotPositionGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotVelocityGoal::kJointsFieldNumber;
const int RobotVelocityGoal::kCartesianFieldNumber;
#endif  // !_MSC_VER

RobotVelocityGoal::RobotVelocityGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.RobotVelocityGoal)
}

void RobotVelocityGoal::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
  cartesian_ = const_cast< ::abb::egm::wrapper::CartesianVelocity*>(&::abb::egm::wrapper::CartesianVelocity::default_instance());
}

RobotVelocityGoal::RobotVelocityGoal(const RobotVelocityGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.RobotVelocityGoal)
}

void RobotVelocityGoal::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesian_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotVelocityGoal::~RobotVelocityGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  SharedDtor();
}

void RobotVelocityGoal::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesian_;
  }
}

void RobotVelocityGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotVelocityGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotVelocityGoal_descriptor_;
}

const RobotVelocityGoal& RobotVelocityGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

RobotVelocityGoal* RobotVelocityGoal::default_instance_ = NULL;

RobotVelocityGoal* RobotVelocityGoal::New() const {
  return new RobotVelocityGoal;
}

void RobotVelocityGoal::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::wrapper::Joints::Clear();
    }
    if (has_cartesian()) {
      if (cartesian_ != NULL) cartesian_->::abb::egm::wrapper::CartesianVelocity::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotVelocityGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesian;
        break;
      }

      // optional .abb.egm.wrapper.CartesianVelocity cartesian = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  return false;
#undef DO_
}

void RobotVelocityGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  // optional .abb.egm.wrapper.Joints joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.wrapper.CartesianVelocity cartesian = 2;
  if (has_cartesian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesian(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.RobotVelocityGoal)
}

::google::protobuf::uint8* RobotVelocityGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  // optional .abb.egm.wrapper.Joints joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.wrapper.CartesianVelocity cartesian = 2;
  if (has_cartesian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesian(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.RobotVelocityGoal)
  return target;
}

int RobotVelocityGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Joints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.wrapper.CartesianVelocity cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesian());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotVelocityGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotVelocityGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotVelocityGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotVelocityGoal::MergeFrom(const RobotVelocityGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::wrapper::Joints::MergeFrom(from.joints());
    }
    if (from.has_cartesian()) {
      mutable_cartesian()->::abb::egm::wrapper::CartesianVelocity::MergeFrom(from.cartesian());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotVelocityGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotVelocityGoal::CopyFrom(const RobotVelocityGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotVelocityGoal::IsInitialized() const {

  return true;
}

void RobotVelocityGoal::Swap(RobotVelocityGoal* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesian_, other->cartesian_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotVelocityGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotVelocityGoal_descriptor_;
  metadata.reflection = RobotVelocityGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TrajectoryGoal::kPointsFieldNumber;
#endif  // !_MSC_VER

TrajectoryGoal::TrajectoryGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.TrajectoryGoal)
}

void TrajectoryGoal::InitAsDefaultInstance() {
}

TrajectoryGoal::TrajectoryGoal(const TrajectoryGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.TrajectoryGoal)
}

void TrajectoryGoal::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrajectoryGoal::~TrajectoryGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.TrajectoryGoal)
  SharedDtor();
}

void TrajectoryGoal::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TrajectoryGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrajectoryGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrajectoryGoal_descriptor_;
}

const TrajectoryGoal& TrajectoryGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

TrajectoryGoal* TrajectoryGoal::default_instance_ = NULL;

TrajectoryGoal* TrajectoryGoal::New() const {
  return new TrajectoryGoal;
}

void TrajectoryGoal::Clear() {
  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TrajectoryGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.TrajectoryGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .abb.egm.wrapper.trajectory.PointGoal points = 1;
      case 1: {
        if (tag == 10) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_points;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.TrajectoryGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.TrajectoryGoal)
  return false;
#undef DO_
}

void TrajectoryGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.TrajectoryGoal)
  // repeated .abb.egm.wrapper.trajectory.PointGoal points = 1;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->points(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.TrajectoryGoal)
}

::google::protobuf::uint8* TrajectoryGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.TrajectoryGoal)
  // repeated .abb.egm.wrapper.trajectory.PointGoal points = 1;
  for (int i = 0; i < this->points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->points(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.TrajectoryGoal)
  return target;
}

int TrajectoryGoal::ByteSize() const {
  int total_size = 0;

  // repeated .abb.egm.wrapper.trajectory.PointGoal points = 1;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->points(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrajectoryGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TrajectoryGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TrajectoryGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TrajectoryGoal::MergeFrom(const TrajectoryGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  points_.MergeFrom(from.points_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TrajectoryGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrajectoryGoal::CopyFrom(const TrajectoryGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrajectoryGoal::IsInitialized() const {

  return true;
}

void TrajectoryGoal::Swap(TrajectoryGoal* other) {
  if (other != this) {
    points_.Swap(&other->points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TrajectoryGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrajectoryGoal_descriptor_;
  metadata.reflection = TrajectoryGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StaticPositionGoal::kRobotFieldNumber;
const int StaticPositionGoal::kExternalFieldNumber;
#endif  // !_MSC_VER

StaticPositionGoal::StaticPositionGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.StaticPositionGoal)
}

void StaticPositionGoal::InitAsDefaultInstance() {
  robot_ = const_cast< ::abb::egm::wrapper::trajectory::RobotPositionGoal*>(&::abb::egm::wrapper::trajectory::RobotPositionGoal::default_instance());
  external_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
}

StaticPositionGoal::StaticPositionGoal(const StaticPositionGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.StaticPositionGoal)
}

void StaticPositionGoal::SharedCtor() {
  _cached_size_ = 0;
  robot_ = NULL;
  external_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StaticPositionGoal::~StaticPositionGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.StaticPositionGoal)
  SharedDtor();
}

void StaticPositionGoal::SharedDtor() {
  if (this != default_instance_) {
    delete robot_;
    delete external_;
  }
}

void StaticPositionGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StaticPositionGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StaticPositionGoal_descriptor_;
}

const StaticPositionGoal& StaticPositionGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

StaticPositionGoal* StaticPositionGoal::default_instance_ = NULL;

StaticPositionGoal* StaticPositionGoal::New() const {
  return new StaticPositionGoal;
}

void StaticPositionGoal::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_robot()) {
      if (robot_ != NULL) robot_->::abb::egm::wrapper::trajectory::RobotPositionGoal::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::abb::egm::wrapper::Joints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StaticPositionGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.StaticPositionGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.trajectory.RobotPositionGoal robot = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_external;
        break;
      }

      // optional .abb.egm.wrapper.Joints external = 2;
      case 2: {
        if (tag == 18) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.StaticPositionGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.StaticPositionGoal)
  return false;
#undef DO_
}

void StaticPositionGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.StaticPositionGoal)
  // optional .abb.egm.wrapper.trajectory.RobotPositionGoal robot = 1;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->robot(), output);
  }

  // optional .abb.egm.wrapper.Joints external = 2;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->external(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.StaticPositionGoal)
}

::google::protobuf::uint8* StaticPositionGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.StaticPositionGoal)
  // optional .abb.egm.wrapper.trajectory.RobotPositionGoal robot = 1;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->robot(), target);
  }

  // optional .abb.egm.wrapper.Joints external = 2;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->external(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.StaticPositionGoal)
  return target;
}

int StaticPositionGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.trajectory.RobotPositionGoal robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot());
    }

    // optional .abb.egm.wrapper.Joints external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StaticPositionGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StaticPositionGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StaticPositionGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StaticPositionGoal::MergeFrom(const StaticPositionGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robot()) {
      mutable_robot()->::abb::egm::wrapper::trajectory::RobotPositionGoal::MergeFrom(from.robot());
    }
    if (from.has_external()) {
      mutable_external()->::abb::egm::wrapper::Joints::MergeFrom(from.external());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StaticPositionGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StaticPositionGoal::CopyFrom(const StaticPositionGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticPositionGoal::IsInitialized() const {

  return true;
}

void StaticPositionGoal::Swap(StaticPositionGoal* other) {
  if (other != this) {
    std::swap(robot_, other->robot_);
    std::swap(external_, other->external_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StaticPositionGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StaticPositionGoal_descriptor_;
  metadata.reflection = StaticPositionGoal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StaticVelocityGoal::kRobotFieldNumber;
const int StaticVelocityGoal::kExternalFieldNumber;
#endif  // !_MSC_VER

StaticVelocityGoal::StaticVelocityGoal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.StaticVelocityGoal)
}

void StaticVelocityGoal::InitAsDefaultInstance() {
  robot_ = const_cast< ::abb::egm::wrapper::trajectory::RobotVelocityGoal*>(&::abb::egm::wrapper::trajectory::RobotVelocityGoal::default_instance());
  external_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
}

StaticVelocityGoal::StaticVelocityGoal(const StaticVelocityGoal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.StaticVelocityGoal)
}

void StaticVelocityGoal::SharedCtor() {
  _cached_size_ = 0;
  robot_ = NULL;
  external_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StaticVelocityGoal::~StaticVelocityGoal() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  SharedDtor();
}

void StaticVelocityGoal::SharedDtor() {
  if (this != default_instance_) {
    delete robot_;
    delete external_;
  }
}

void StaticVelocityGoal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StaticVelocityGoal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StaticVelocityGoal_descriptor_;
}

const StaticVelocityGoal& StaticVelocityGoal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

StaticVelocityGoal* StaticVelocityGoal::default_instance_ = NULL;

StaticVelocityGoal* StaticVelocityGoal::New() const {
  return new StaticVelocityGoal;
}

void StaticVelocityGoal::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_robot()) {
      if (robot_ != NULL) robot_->::abb::egm::wrapper::trajectory::RobotVelocityGoal::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::abb::egm::wrapper::Joints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StaticVelocityGoal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.trajectory.RobotVelocityGoal robot = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_external;
        break;
      }

      // optional .abb.egm.wrapper.Joints external = 2;
      case 2: {
        if (tag == 18) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  return false;
#undef DO_
}

void StaticVelocityGoal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  // optional .abb.egm.wrapper.trajectory.RobotVelocityGoal robot = 1;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->robot(), output);
  }

  // optional .abb.egm.wrapper.Joints external = 2;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->external(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.StaticVelocityGoal)
}

::google::protobuf::uint8* StaticVelocityGoal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  // optional .abb.egm.wrapper.trajectory.RobotVelocityGoal robot = 1;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->robot(), target);
  }

  // optional .abb.egm.wrapper.Joints external = 2;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->external(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.StaticVelocityGoal)
  return target;
}

int StaticVelocityGoal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.trajectory.RobotVelocityGoal robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot());
    }

    // optional .abb.egm.wrapper.Joints external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StaticVelocityGoal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StaticVelocityGoal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StaticVelocityGoal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StaticVelocityGoal::MergeFrom(const StaticVelocityGoal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robot()) {
      mutable_robot()->::abb::egm::wrapper::trajectory::RobotVelocityGoal::MergeFrom(from.robot());
    }
    if (from.has_external()) {
      mutable_external()->::abb::egm::wrapper::Joints::MergeFrom(from.external());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StaticVelocityGoal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StaticVelocityGoal::CopyFrom(const StaticVelocityGoal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticVelocityGoal::IsInitialized() const {

  return true;
}

void StaticVelocityGoal::Swap(StaticVelocityGoal* other) {
  if (other != this) {
    std::swap(robot_, other->robot_);
    std::swap(external_, other->external_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StaticVelocityGoal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StaticVelocityGoal_descriptor_;
  metadata.reflection = StaticVelocityGoal_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ExecutionProgress_State_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutionProgress_State_descriptor_;
}
bool ExecutionProgress_State_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ExecutionProgress_State ExecutionProgress::UNDEFINED;
const ExecutionProgress_State ExecutionProgress::NORMAL;
const ExecutionProgress_State ExecutionProgress::RAMP_DOWN;
const ExecutionProgress_State ExecutionProgress::STATIC_GOAL;
const ExecutionProgress_State ExecutionProgress::State_MIN;
const ExecutionProgress_State ExecutionProgress::State_MAX;
const int ExecutionProgress::State_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ExecutionProgress_SubState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutionProgress_SubState_descriptor_;
}
bool ExecutionProgress_SubState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ExecutionProgress_SubState ExecutionProgress::NONE;
const ExecutionProgress_SubState ExecutionProgress::RUNNING;
const ExecutionProgress_SubState ExecutionProgress::FINISHED;
const ExecutionProgress_SubState ExecutionProgress::SubState_MIN;
const ExecutionProgress_SubState ExecutionProgress::SubState_MAX;
const int ExecutionProgress::SubState_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ExecutionProgress::kStateFieldNumber;
const int ExecutionProgress::kSubStateFieldNumber;
const int ExecutionProgress::kInputsFieldNumber;
const int ExecutionProgress::kOutputsFieldNumber;
const int ExecutionProgress::kTimePassedFieldNumber;
const int ExecutionProgress::kGoalActiveFieldNumber;
const int ExecutionProgress::kGoalFieldNumber;
const int ExecutionProgress::kActiveTrajectoryFieldNumber;
const int ExecutionProgress::kPendingTrajectoriesFieldNumber;
#endif  // !_MSC_VER

ExecutionProgress::ExecutionProgress()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.trajectory.ExecutionProgress)
}

void ExecutionProgress::InitAsDefaultInstance() {
  inputs_ = const_cast< ::abb::egm::wrapper::Input*>(&::abb::egm::wrapper::Input::default_instance());
  outputs_ = const_cast< ::abb::egm::wrapper::Output*>(&::abb::egm::wrapper::Output::default_instance());
  goal_ = const_cast< ::abb::egm::wrapper::trajectory::PointGoal*>(&::abb::egm::wrapper::trajectory::PointGoal::default_instance());
  active_trajectory_ = const_cast< ::abb::egm::wrapper::trajectory::TrajectoryGoal*>(&::abb::egm::wrapper::trajectory::TrajectoryGoal::default_instance());
}

ExecutionProgress::ExecutionProgress(const ExecutionProgress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.trajectory.ExecutionProgress)
}

void ExecutionProgress::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  sub_state_ = 0;
  inputs_ = NULL;
  outputs_ = NULL;
  time_passed_ = 0;
  goal_active_ = false;
  goal_ = NULL;
  active_trajectory_ = NULL;
  pending_trajectories_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutionProgress::~ExecutionProgress() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.trajectory.ExecutionProgress)
  SharedDtor();
}

void ExecutionProgress::SharedDtor() {
  if (this != default_instance_) {
    delete inputs_;
    delete outputs_;
    delete goal_;
    delete active_trajectory_;
  }
}

void ExecutionProgress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutionProgress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutionProgress_descriptor_;
}

const ExecutionProgress& ExecutionProgress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_5ftrajectory_2eproto();
  return *default_instance_;
}

ExecutionProgress* ExecutionProgress::default_instance_ = NULL;

ExecutionProgress* ExecutionProgress::New() const {
  return new ExecutionProgress;
}

void ExecutionProgress::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ExecutionProgress*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(state_, sub_state_);
    if (has_inputs()) {
      if (inputs_ != NULL) inputs_->::abb::egm::wrapper::Input::Clear();
    }
    if (has_outputs()) {
      if (outputs_ != NULL) outputs_->::abb::egm::wrapper::Output::Clear();
    }
    time_passed_ = 0;
    goal_active_ = false;
    if (has_goal()) {
      if (goal_ != NULL) goal_->::abb::egm::wrapper::trajectory::PointGoal::Clear();
    }
    if (has_active_trajectory()) {
      if (active_trajectory_ != NULL) active_trajectory_->::abb::egm::wrapper::trajectory::TrajectoryGoal::Clear();
    }
  }
  pending_trajectories_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutionProgress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.trajectory.ExecutionProgress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.trajectory.ExecutionProgress.State state = 1 [default = UNDEFINED];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::trajectory::ExecutionProgress_State_IsValid(value)) {
            set_state(static_cast< ::abb::egm::wrapper::trajectory::ExecutionProgress_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sub_state;
        break;
      }

      // optional .abb.egm.wrapper.trajectory.ExecutionProgress.SubState sub_state = 2 [default = NONE];
      case 2: {
        if (tag == 16) {
         parse_sub_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::trajectory::ExecutionProgress_SubState_IsValid(value)) {
            set_sub_state(static_cast< ::abb::egm::wrapper::trajectory::ExecutionProgress_SubState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_inputs;
        break;
      }

      // optional .abb.egm.wrapper.Input inputs = 3;
      case 3: {
        if (tag == 26) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_outputs;
        break;
      }

      // optional .abb.egm.wrapper.Output outputs = 4;
      case 4: {
        if (tag == 34) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_outputs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_time_passed;
        break;
      }

      // optional double time_passed = 5;
      case 5: {
        if (tag == 41) {
         parse_time_passed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_passed_)));
          set_has_time_passed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_goal_active;
        break;
      }

      // optional bool goal_active = 6;
      case 6: {
        if (tag == 48) {
         parse_goal_active:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &goal_active_)));
          set_has_goal_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_goal;
        break;
      }

      // optional .abb.egm.wrapper.trajectory.PointGoal goal = 7;
      case 7: {
        if (tag == 58) {
         parse_goal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_goal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_active_trajectory;
        break;
      }

      // optional .abb.egm.wrapper.trajectory.TrajectoryGoal active_trajectory = 8;
      case 8: {
        if (tag == 66) {
         parse_active_trajectory:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_active_trajectory()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_pending_trajectories;
        break;
      }

      // optional uint32 pending_trajectories = 9;
      case 9: {
        if (tag == 72) {
         parse_pending_trajectories:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pending_trajectories_)));
          set_has_pending_trajectories();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.trajectory.ExecutionProgress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.trajectory.ExecutionProgress)
  return false;
#undef DO_
}

void ExecutionProgress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.trajectory.ExecutionProgress)
  // optional .abb.egm.wrapper.trajectory.ExecutionProgress.State state = 1 [default = UNDEFINED];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // optional .abb.egm.wrapper.trajectory.ExecutionProgress.SubState sub_state = 2 [default = NONE];
  if (has_sub_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->sub_state(), output);
  }

  // optional .abb.egm.wrapper.Input inputs = 3;
  if (has_inputs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->inputs(), output);
  }

  // optional .abb.egm.wrapper.Output outputs = 4;
  if (has_outputs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->outputs(), output);
  }

  // optional double time_passed = 5;
  if (has_time_passed()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->time_passed(), output);
  }

  // optional bool goal_active = 6;
  if (has_goal_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->goal_active(), output);
  }

  // optional .abb.egm.wrapper.trajectory.PointGoal goal = 7;
  if (has_goal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->goal(), output);
  }

  // optional .abb.egm.wrapper.trajectory.TrajectoryGoal active_trajectory = 8;
  if (has_active_trajectory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->active_trajectory(), output);
  }

  // optional uint32 pending_trajectories = 9;
  if (has_pending_trajectories()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->pending_trajectories(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.trajectory.ExecutionProgress)
}

::google::protobuf::uint8* ExecutionProgress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.trajectory.ExecutionProgress)
  // optional .abb.egm.wrapper.trajectory.ExecutionProgress.State state = 1 [default = UNDEFINED];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // optional .abb.egm.wrapper.trajectory.ExecutionProgress.SubState sub_state = 2 [default = NONE];
  if (has_sub_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->sub_state(), target);
  }

  // optional .abb.egm.wrapper.Input inputs = 3;
  if (has_inputs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->inputs(), target);
  }

  // optional .abb.egm.wrapper.Output outputs = 4;
  if (has_outputs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->outputs(), target);
  }

  // optional double time_passed = 5;
  if (has_time_passed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->time_passed(), target);
  }

  // optional bool goal_active = 6;
  if (has_goal_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->goal_active(), target);
  }

  // optional .abb.egm.wrapper.trajectory.PointGoal goal = 7;
  if (has_goal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->goal(), target);
  }

  // optional .abb.egm.wrapper.trajectory.TrajectoryGoal active_trajectory = 8;
  if (has_active_trajectory()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->active_trajectory(), target);
  }

  // optional uint32 pending_trajectories = 9;
  if (has_pending_trajectories()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->pending_trajectories(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.trajectory.ExecutionProgress)
  return target;
}

int ExecutionProgress::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.trajectory.ExecutionProgress.State state = 1 [default = UNDEFINED];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .abb.egm.wrapper.trajectory.ExecutionProgress.SubState sub_state = 2 [default = NONE];
    if (has_sub_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sub_state());
    }

    // optional .abb.egm.wrapper.Input inputs = 3;
    if (has_inputs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inputs());
    }

    // optional .abb.egm.wrapper.Output outputs = 4;
    if (has_outputs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->outputs());
    }

    // optional double time_passed = 5;
    if (has_time_passed()) {
      total_size += 1 + 8;
    }

    // optional bool goal_active = 6;
    if (has_goal_active()) {
      total_size += 1 + 1;
    }

    // optional .abb.egm.wrapper.trajectory.PointGoal goal = 7;
    if (has_goal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->goal());
    }

    // optional .abb.egm.wrapper.trajectory.TrajectoryGoal active_trajectory = 8;
    if (has_active_trajectory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->active_trajectory());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 pending_trajectories = 9;
    if (has_pending_trajectories()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pending_trajectories());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutionProgress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutionProgress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutionProgress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutionProgress::MergeFrom(const ExecutionProgress& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_sub_state()) {
      set_sub_state(from.sub_state());
    }
    if (from.has_inputs()) {
      mutable_inputs()->::abb::egm::wrapper::Input::MergeFrom(from.inputs());
    }
    if (from.has_outputs()) {
      mutable_outputs()->::abb::egm::wrapper::Output::MergeFrom(from.outputs());
    }
    if (from.has_time_passed()) {
      set_time_passed(from.time_passed());
    }
    if (from.has_goal_active()) {
      set_goal_active(from.goal_active());
    }
    if (from.has_goal()) {
      mutable_goal()->::abb::egm::wrapper::trajectory::PointGoal::MergeFrom(from.goal());
    }
    if (from.has_active_trajectory()) {
      mutable_active_trajectory()->::abb::egm::wrapper::trajectory::TrajectoryGoal::MergeFrom(from.active_trajectory());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_pending_trajectories()) {
      set_pending_trajectories(from.pending_trajectories());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutionProgress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutionProgress::CopyFrom(const ExecutionProgress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutionProgress::IsInitialized() const {

  return true;
}

void ExecutionProgress::Swap(ExecutionProgress* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(sub_state_, other->sub_state_);
    std::swap(inputs_, other->inputs_);
    std::swap(outputs_, other->outputs_);
    std::swap(time_passed_, other->time_passed_);
    std::swap(goal_active_, other->goal_active_);
    std::swap(goal_, other->goal_);
    std::swap(active_trajectory_, other->active_trajectory_);
    std::swap(pending_trajectories_, other->pending_trajectories_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutionProgress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutionProgress_descriptor_;
  metadata.reflection = ExecutionProgress_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace trajectory
}  // namespace wrapper
}  // namespace egm
}  // namespace abb

// @@protoc_insertion_point(global_scope)
