// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "egm_wrapper.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace abb {
namespace egm {
namespace wrapper {

namespace {

const ::google::protobuf::Descriptor* Header_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Header_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Status_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Status_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Clock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Clock_reflection_ = NULL;
const ::google::protobuf::Descriptor* Joints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Joints_reflection_ = NULL;
const ::google::protobuf::Descriptor* JointSpace_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JointSpace_reflection_ = NULL;
const ::google::protobuf::Descriptor* Cartesian_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Cartesian_reflection_ = NULL;
const ::google::protobuf::Descriptor* Euler_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Euler_reflection_ = NULL;
const ::google::protobuf::Descriptor* Quaternion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Quaternion_reflection_ = NULL;
const ::google::protobuf::Descriptor* CartesianPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CartesianPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* CartesianVelocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CartesianVelocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* CartesianSpace_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CartesianSpace_reflection_ = NULL;
const ::google::protobuf::Descriptor* Robot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Robot_reflection_ = NULL;
const ::google::protobuf::Descriptor* External_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  External_reflection_ = NULL;
const ::google::protobuf::Descriptor* Feedback_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Feedback_reflection_ = NULL;
const ::google::protobuf::Descriptor* Planned_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Planned_reflection_ = NULL;
const ::google::protobuf::Descriptor* Input_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Input_reflection_ = NULL;
const ::google::protobuf::Descriptor* Output_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Output_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_egm_5fwrapper_2eproto() {
  protobuf_AddDesc_egm_5fwrapper_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "egm_wrapper.proto");
  GOOGLE_CHECK(file != NULL);
  Header_descriptor_ = file->message_type(0);
  static const int Header_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, sequence_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, message_type_),
  };
  Header_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Header_descriptor_,
      Header::default_instance_,
      Header_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Header));
  Header_MessageType_descriptor_ = Header_descriptor_->enum_type(0);
  Status_descriptor_ = file->message_type(1);
  static const int Status_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, egm_convergence_met_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, egm_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, motor_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, rapid_execution_state_),
  };
  Status_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Status_descriptor_,
      Status::default_instance_,
      Status_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Status));
  Status_EGMState_descriptor_ = Status_descriptor_->enum_type(0);
  Status_MotorState_descriptor_ = Status_descriptor_->enum_type(1);
  Status_RAPIDExecutionState_descriptor_ = Status_descriptor_->enum_type(2);
  Clock_descriptor_ = file->message_type(2);
  static const int Clock_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Clock, sec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Clock, usec_),
  };
  Clock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Clock_descriptor_,
      Clock::default_instance_,
      Clock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Clock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Clock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Clock));
  Joints_descriptor_ = file->message_type(3);
  static const int Joints_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Joints, values_),
  };
  Joints_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Joints_descriptor_,
      Joints::default_instance_,
      Joints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Joints, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Joints, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Joints));
  JointSpace_descriptor_ = file->message_type(4);
  static const int JointSpace_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointSpace, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointSpace, velocity_),
  };
  JointSpace_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JointSpace_descriptor_,
      JointSpace::default_instance_,
      JointSpace_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointSpace, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointSpace, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JointSpace));
  Cartesian_descriptor_ = file->message_type(5);
  static const int Cartesian_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cartesian, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cartesian, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cartesian, z_),
  };
  Cartesian_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Cartesian_descriptor_,
      Cartesian::default_instance_,
      Cartesian_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cartesian, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cartesian, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Cartesian));
  Euler_descriptor_ = file->message_type(6);
  static const int Euler_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Euler, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Euler, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Euler, z_),
  };
  Euler_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Euler_descriptor_,
      Euler::default_instance_,
      Euler_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Euler, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Euler, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Euler));
  Quaternion_descriptor_ = file->message_type(7);
  static const int Quaternion_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, u0_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, u1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, u2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, u3_),
  };
  Quaternion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Quaternion_descriptor_,
      Quaternion::default_instance_,
      Quaternion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Quaternion));
  CartesianPose_descriptor_ = file->message_type(8);
  static const int CartesianPose_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianPose, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianPose, euler_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianPose, quaternion_),
  };
  CartesianPose_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CartesianPose_descriptor_,
      CartesianPose::default_instance_,
      CartesianPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianPose, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianPose, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CartesianPose));
  CartesianVelocity_descriptor_ = file->message_type(9);
  static const int CartesianVelocity_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianVelocity, linear_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianVelocity, angular_),
  };
  CartesianVelocity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CartesianVelocity_descriptor_,
      CartesianVelocity::default_instance_,
      CartesianVelocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianVelocity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianVelocity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CartesianVelocity));
  CartesianSpace_descriptor_ = file->message_type(10);
  static const int CartesianSpace_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianSpace, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianSpace, velocity_),
  };
  CartesianSpace_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CartesianSpace_descriptor_,
      CartesianSpace::default_instance_,
      CartesianSpace_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianSpace, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartesianSpace, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CartesianSpace));
  Robot_descriptor_ = file->message_type(11);
  static const int Robot_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, cartesian_),
  };
  Robot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Robot_descriptor_,
      Robot::default_instance_,
      Robot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Robot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Robot));
  External_descriptor_ = file->message_type(12);
  static const int External_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(External, joints_),
  };
  External_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      External_descriptor_,
      External::default_instance_,
      External_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(External, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(External, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(External));
  Feedback_descriptor_ = file->message_type(13);
  static const int Feedback_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Feedback, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Feedback, external_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Feedback, time_),
  };
  Feedback_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Feedback_descriptor_,
      Feedback::default_instance_,
      Feedback_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Feedback, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Feedback, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Feedback));
  Planned_descriptor_ = file->message_type(14);
  static const int Planned_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Planned, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Planned, external_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Planned, time_),
  };
  Planned_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Planned_descriptor_,
      Planned::default_instance_,
      Planned_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Planned, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Planned, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Planned));
  Input_descriptor_ = file->message_type(15);
  static const int Input_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, feedback_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, planned_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, status_),
  };
  Input_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Input_descriptor_,
      Input::default_instance_,
      Input_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Input));
  Output_descriptor_ = file->message_type(16);
  static const int Output_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Output, robot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Output, external_),
  };
  Output_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Output_descriptor_,
      Output::default_instance_,
      Output_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Output, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Output, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Output));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_egm_5fwrapper_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Header_descriptor_, &Header::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Status_descriptor_, &Status::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Clock_descriptor_, &Clock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Joints_descriptor_, &Joints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JointSpace_descriptor_, &JointSpace::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Cartesian_descriptor_, &Cartesian::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Euler_descriptor_, &Euler::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Quaternion_descriptor_, &Quaternion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CartesianPose_descriptor_, &CartesianPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CartesianVelocity_descriptor_, &CartesianVelocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CartesianSpace_descriptor_, &CartesianSpace::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Robot_descriptor_, &Robot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    External_descriptor_, &External::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Feedback_descriptor_, &Feedback::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Planned_descriptor_, &Planned::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Input_descriptor_, &Input::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Output_descriptor_, &Output::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_egm_5fwrapper_2eproto() {
  delete Header::default_instance_;
  delete Header_reflection_;
  delete Status::default_instance_;
  delete Status_reflection_;
  delete Clock::default_instance_;
  delete Clock_reflection_;
  delete Joints::default_instance_;
  delete Joints_reflection_;
  delete JointSpace::default_instance_;
  delete JointSpace_reflection_;
  delete Cartesian::default_instance_;
  delete Cartesian_reflection_;
  delete Euler::default_instance_;
  delete Euler_reflection_;
  delete Quaternion::default_instance_;
  delete Quaternion_reflection_;
  delete CartesianPose::default_instance_;
  delete CartesianPose_reflection_;
  delete CartesianVelocity::default_instance_;
  delete CartesianVelocity_reflection_;
  delete CartesianSpace::default_instance_;
  delete CartesianSpace_reflection_;
  delete Robot::default_instance_;
  delete Robot_reflection_;
  delete External::default_instance_;
  delete External_reflection_;
  delete Feedback::default_instance_;
  delete Feedback_reflection_;
  delete Planned::default_instance_;
  delete Planned_reflection_;
  delete Input::default_instance_;
  delete Input_reflection_;
  delete Output::default_instance_;
  delete Output_reflection_;
}

void protobuf_AddDesc_egm_5fwrapper_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021egm_wrapper.proto\022\017abb.egm.wrapper\"\243\001\n"
    "\006Header\022\027\n\017sequence_number\030\001 \001(\r\022\022\n\ntime"
    "_stamp\030\002 \001(\r\022D\n\014message_type\030\003 \001(\0162#.abb"
    ".egm.wrapper.Header.MessageType:\tUNDEFIN"
    "ED\"&\n\013MessageType\022\r\n\tUNDEFINED\020\000\022\010\n\004DATA"
    "\020\001\"\366\003\n\006Status\022\033\n\023egm_convergence_met\030\001 \001"
    "(\010\022B\n\tegm_state\030\002 \001(\0162 .abb.egm.wrapper."
    "Status.EGMState:\rEGM_UNDEFINED\022I\n\013motor_"
    "state\030\003 \001(\0162\".abb.egm.wrapper.Status.Mot"
    "orState:\020MOTORS_UNDEFINED\022[\n\025rapid_execu"
    "tion_state\030\004 \001(\0162+.abb.egm.wrapper.Statu"
    "s.RAPIDExecutionState:\017RAPID_UNDEFINED\"N"
    "\n\010EGMState\022\021\n\rEGM_UNDEFINED\020\000\022\r\n\tEGM_ERR"
    "OR\020\001\022\017\n\013EGM_STOPPED\020\002\022\017\n\013EGM_RUNNING\020\003\"A"
    "\n\nMotorState\022\024\n\020MOTORS_UNDEFINED\020\000\022\r\n\tMO"
    "TORS_ON\020\001\022\016\n\nMOTORS_OFF\020\002\"P\n\023RAPIDExecut"
    "ionState\022\023\n\017RAPID_UNDEFINED\020\000\022\021\n\rRAPID_S"
    "TOPPED\020\001\022\021\n\rRAPID_RUNNING\020\002\"\"\n\005Clock\022\013\n\003"
    "sec\030\001 \001(\004\022\014\n\004usec\030\002 \001(\004\"\030\n\006Joints\022\016\n\006val"
    "ues\030\001 \003(\001\"b\n\nJointSpace\022)\n\010position\030\001 \001("
    "\0132\027.abb.egm.wrapper.Joints\022)\n\010velocity\030\002"
    " \001(\0132\027.abb.egm.wrapper.Joints\",\n\tCartesi"
    "an\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"(\n\005E"
    "uler\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"<\n"
    "\nQuaternion\022\n\n\002u0\030\001 \001(\001\022\n\n\002u1\030\002 \001(\001\022\n\n\002u"
    "2\030\003 \001(\001\022\n\n\002u3\030\004 \001(\001\"\225\001\n\rCartesianPose\022,\n"
    "\010position\030\001 \001(\0132\032.abb.egm.wrapper.Cartes"
    "ian\022%\n\005euler\030\002 \001(\0132\026.abb.egm.wrapper.Eul"
    "er\022/\n\nquaternion\030\003 \001(\0132\033.abb.egm.wrapper"
    ".Quaternion\"h\n\021CartesianVelocity\022*\n\006line"
    "ar\030\001 \001(\0132\032.abb.egm.wrapper.Cartesian\022\'\n\007"
    "angular\030\002 \001(\0132\026.abb.egm.wrapper.Euler\"t\n"
    "\016CartesianSpace\022,\n\004pose\030\001 \001(\0132\036.abb.egm."
    "wrapper.CartesianPose\0224\n\010velocity\030\002 \001(\0132"
    "\".abb.egm.wrapper.CartesianVelocity\"h\n\005R"
    "obot\022+\n\006joints\030\001 \001(\0132\033.abb.egm.wrapper.J"
    "ointSpace\0222\n\tcartesian\030\002 \001(\0132\037.abb.egm.w"
    "rapper.CartesianSpace\"7\n\010External\022+\n\006joi"
    "nts\030\001 \001(\0132\033.abb.egm.wrapper.JointSpace\"\204"
    "\001\n\010Feedback\022%\n\005robot\030\001 \001(\0132\026.abb.egm.wra"
    "pper.Robot\022+\n\010external\030\002 \001(\0132\031.abb.egm.w"
    "rapper.External\022$\n\004time\030\003 \001(\0132\026.abb.egm."
    "wrapper.Clock\"\203\001\n\007Planned\022%\n\005robot\030\001 \001(\013"
    "2\026.abb.egm.wrapper.Robot\022+\n\010external\030\002 \001"
    "(\0132\031.abb.egm.wrapper.External\022$\n\004time\030\003 "
    "\001(\0132\026.abb.egm.wrapper.Clock\"\261\001\n\005Input\022\'\n"
    "\006header\030\001 \001(\0132\027.abb.egm.wrapper.Header\022+"
    "\n\010feedback\030\002 \001(\0132\031.abb.egm.wrapper.Feedb"
    "ack\022)\n\007planned\030\003 \001(\0132\030.abb.egm.wrapper.P"
    "lanned\022\'\n\006status\030\004 \001(\0132\027.abb.egm.wrapper"
    ".Status\"\\\n\006Output\022%\n\005robot\030\001 \001(\0132\026.abb.e"
    "gm.wrapper.Robot\022+\n\010external\030\002 \001(\0132\031.abb"
    ".egm.wrapper.External", 2101);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "egm_wrapper.proto", &protobuf_RegisterTypes);
  Header::default_instance_ = new Header();
  Status::default_instance_ = new Status();
  Clock::default_instance_ = new Clock();
  Joints::default_instance_ = new Joints();
  JointSpace::default_instance_ = new JointSpace();
  Cartesian::default_instance_ = new Cartesian();
  Euler::default_instance_ = new Euler();
  Quaternion::default_instance_ = new Quaternion();
  CartesianPose::default_instance_ = new CartesianPose();
  CartesianVelocity::default_instance_ = new CartesianVelocity();
  CartesianSpace::default_instance_ = new CartesianSpace();
  Robot::default_instance_ = new Robot();
  External::default_instance_ = new External();
  Feedback::default_instance_ = new Feedback();
  Planned::default_instance_ = new Planned();
  Input::default_instance_ = new Input();
  Output::default_instance_ = new Output();
  Header::default_instance_->InitAsDefaultInstance();
  Status::default_instance_->InitAsDefaultInstance();
  Clock::default_instance_->InitAsDefaultInstance();
  Joints::default_instance_->InitAsDefaultInstance();
  JointSpace::default_instance_->InitAsDefaultInstance();
  Cartesian::default_instance_->InitAsDefaultInstance();
  Euler::default_instance_->InitAsDefaultInstance();
  Quaternion::default_instance_->InitAsDefaultInstance();
  CartesianPose::default_instance_->InitAsDefaultInstance();
  CartesianVelocity::default_instance_->InitAsDefaultInstance();
  CartesianSpace::default_instance_->InitAsDefaultInstance();
  Robot::default_instance_->InitAsDefaultInstance();
  External::default_instance_->InitAsDefaultInstance();
  Feedback::default_instance_->InitAsDefaultInstance();
  Planned::default_instance_->InitAsDefaultInstance();
  Input::default_instance_->InitAsDefaultInstance();
  Output::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_egm_5fwrapper_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_egm_5fwrapper_2eproto {
  StaticDescriptorInitializer_egm_5fwrapper_2eproto() {
    protobuf_AddDesc_egm_5fwrapper_2eproto();
  }
} static_descriptor_initializer_egm_5fwrapper_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Header_MessageType_descriptor_;
}
bool Header_MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Header_MessageType Header::UNDEFINED;
const Header_MessageType Header::DATA;
const Header_MessageType Header::MessageType_MIN;
const Header_MessageType Header::MessageType_MAX;
const int Header::MessageType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Header::kSequenceNumberFieldNumber;
const int Header::kTimeStampFieldNumber;
const int Header::kMessageTypeFieldNumber;
#endif  // !_MSC_VER

Header::Header()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Header)
}

void Header::InitAsDefaultInstance() {
}

Header::Header(const Header& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Header)
}

void Header::SharedCtor() {
  _cached_size_ = 0;
  sequence_number_ = 0u;
  time_stamp_ = 0u;
  message_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Header)
  SharedDtor();
}

void Header::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Header::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Header_descriptor_;
}

const Header& Header::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Header* Header::default_instance_ = NULL;

Header* Header::New() const {
  return new Header;
}

void Header::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Header*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(sequence_number_, message_type_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sequence_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_number_)));
          set_has_sequence_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // optional uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_message_type;
        break;
      }

      // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
      case 3: {
        if (tag == 24) {
         parse_message_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Header_MessageType_IsValid(value)) {
            set_message_type(static_cast< ::abb::egm::wrapper::Header_MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Header)
  return false;
#undef DO_
}

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Header)
  // optional uint32 sequence_number = 1;
  if (has_sequence_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sequence_number(), output);
  }

  // optional uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->message_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Header)
}

::google::protobuf::uint8* Header::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Header)
  // optional uint32 sequence_number = 1;
  if (has_sequence_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sequence_number(), target);
  }

  // optional uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (has_message_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->message_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Header)
  return target;
}

int Header::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 sequence_number = 1;
    if (has_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence_number());
    }

    // optional uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
    if (has_message_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Header::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Header* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Header*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Header::MergeFrom(const Header& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sequence_number()) {
      set_sequence_number(from.sequence_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_message_type()) {
      set_message_type(from.message_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Header::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Header::CopyFrom(const Header& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {

  return true;
}

void Header::Swap(Header* other) {
  if (other != this) {
    std::swap(sequence_number_, other->sequence_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(message_type_, other->message_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Header::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Header_descriptor_;
  metadata.reflection = Header_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_EGMState_descriptor_;
}
bool Status_EGMState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Status_EGMState Status::EGM_UNDEFINED;
const Status_EGMState Status::EGM_ERROR;
const Status_EGMState Status::EGM_STOPPED;
const Status_EGMState Status::EGM_RUNNING;
const Status_EGMState Status::EGMState_MIN;
const Status_EGMState Status::EGMState_MAX;
const int Status::EGMState_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_MotorState_descriptor_;
}
bool Status_MotorState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Status_MotorState Status::MOTORS_UNDEFINED;
const Status_MotorState Status::MOTORS_ON;
const Status_MotorState Status::MOTORS_OFF;
const Status_MotorState Status::MotorState_MIN;
const Status_MotorState Status::MotorState_MAX;
const int Status::MotorState_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_RAPIDExecutionState_descriptor_;
}
bool Status_RAPIDExecutionState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Status_RAPIDExecutionState Status::RAPID_UNDEFINED;
const Status_RAPIDExecutionState Status::RAPID_STOPPED;
const Status_RAPIDExecutionState Status::RAPID_RUNNING;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MIN;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MAX;
const int Status::RAPIDExecutionState_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Status::kEgmConvergenceMetFieldNumber;
const int Status::kEgmStateFieldNumber;
const int Status::kMotorStateFieldNumber;
const int Status::kRapidExecutionStateFieldNumber;
#endif  // !_MSC_VER

Status::Status()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Status)
}

void Status::InitAsDefaultInstance() {
}

Status::Status(const Status& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Status)
}

void Status::SharedCtor() {
  _cached_size_ = 0;
  egm_convergence_met_ = false;
  egm_state_ = 0;
  motor_state_ = 0;
  rapid_execution_state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Status)
  SharedDtor();
}

void Status::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Status::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Status::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}

const Status& Status::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Status* Status::default_instance_ = NULL;

Status* Status::New() const {
  return new Status;
}

void Status::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Status*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(egm_convergence_met_, rapid_execution_state_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Status)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool egm_convergence_met = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &egm_convergence_met_)));
          set_has_egm_convergence_met();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_egm_state;
        break;
      }

      // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
      case 2: {
        if (tag == 16) {
         parse_egm_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_EGMState_IsValid(value)) {
            set_egm_state(static_cast< ::abb::egm::wrapper::Status_EGMState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_motor_state;
        break;
      }

      // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
      case 3: {
        if (tag == 24) {
         parse_motor_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_MotorState_IsValid(value)) {
            set_motor_state(static_cast< ::abb::egm::wrapper::Status_MotorState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_rapid_execution_state;
        break;
      }

      // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
      case 4: {
        if (tag == 32) {
         parse_rapid_execution_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value)) {
            set_rapid_execution_state(static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Status)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Status)
  return false;
#undef DO_
}

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Status)
  // optional bool egm_convergence_met = 1;
  if (has_egm_convergence_met()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->egm_convergence_met(), output);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (has_egm_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->egm_state(), output);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (has_motor_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->motor_state(), output);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (has_rapid_execution_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->rapid_execution_state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Status)
}

::google::protobuf::uint8* Status::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Status)
  // optional bool egm_convergence_met = 1;
  if (has_egm_convergence_met()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->egm_convergence_met(), target);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (has_egm_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->egm_state(), target);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (has_motor_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->motor_state(), target);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (has_rapid_execution_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->rapid_execution_state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Status)
  return target;
}

int Status::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool egm_convergence_met = 1;
    if (has_egm_convergence_met()) {
      total_size += 1 + 1;
    }

    // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
    if (has_egm_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->egm_state());
    }

    // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
    if (has_motor_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->motor_state());
    }

    // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
    if (has_rapid_execution_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rapid_execution_state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Status::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Status* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Status*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_egm_convergence_met()) {
      set_egm_convergence_met(from.egm_convergence_met());
    }
    if (from.has_egm_state()) {
      set_egm_state(from.egm_state());
    }
    if (from.has_motor_state()) {
      set_motor_state(from.motor_state());
    }
    if (from.has_rapid_execution_state()) {
      set_rapid_execution_state(from.rapid_execution_state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Status::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {

  return true;
}

void Status::Swap(Status* other) {
  if (other != this) {
    std::swap(egm_convergence_met_, other->egm_convergence_met_);
    std::swap(egm_state_, other->egm_state_);
    std::swap(motor_state_, other->motor_state_);
    std::swap(rapid_execution_state_, other->rapid_execution_state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Status::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Status_descriptor_;
  metadata.reflection = Status_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Clock::kSecFieldNumber;
const int Clock::kUsecFieldNumber;
#endif  // !_MSC_VER

Clock::Clock()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Clock)
}

void Clock::InitAsDefaultInstance() {
}

Clock::Clock(const Clock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Clock)
}

void Clock::SharedCtor() {
  _cached_size_ = 0;
  sec_ = GOOGLE_ULONGLONG(0);
  usec_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Clock::~Clock() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Clock)
  SharedDtor();
}

void Clock::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Clock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Clock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Clock_descriptor_;
}

const Clock& Clock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Clock* Clock::default_instance_ = NULL;

Clock* Clock::New() const {
  return new Clock;
}

void Clock::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Clock*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(sec_, usec_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Clock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Clock)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sec = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sec_)));
          set_has_sec();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_usec;
        break;
      }

      // optional uint64 usec = 2;
      case 2: {
        if (tag == 16) {
         parse_usec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &usec_)));
          set_has_usec();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Clock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Clock)
  return false;
#undef DO_
}

void Clock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Clock)
  // optional uint64 sec = 1;
  if (has_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sec(), output);
  }

  // optional uint64 usec = 2;
  if (has_usec()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->usec(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Clock)
}

::google::protobuf::uint8* Clock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Clock)
  // optional uint64 sec = 1;
  if (has_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sec(), target);
  }

  // optional uint64 usec = 2;
  if (has_usec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->usec(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Clock)
  return target;
}

int Clock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 sec = 1;
    if (has_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sec());
    }

    // optional uint64 usec = 2;
    if (has_usec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->usec());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Clock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Clock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Clock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Clock::MergeFrom(const Clock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sec()) {
      set_sec(from.sec());
    }
    if (from.has_usec()) {
      set_usec(from.usec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Clock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Clock::CopyFrom(const Clock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Clock::IsInitialized() const {

  return true;
}

void Clock::Swap(Clock* other) {
  if (other != this) {
    std::swap(sec_, other->sec_);
    std::swap(usec_, other->usec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Clock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Clock_descriptor_;
  metadata.reflection = Clock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Joints::kValuesFieldNumber;
#endif  // !_MSC_VER

Joints::Joints()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Joints)
}

void Joints::InitAsDefaultInstance() {
}

Joints::Joints(const Joints& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Joints)
}

void Joints::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Joints::~Joints() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Joints)
  SharedDtor();
}

void Joints::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Joints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Joints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Joints_descriptor_;
}

const Joints& Joints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Joints* Joints::default_instance_ = NULL;

Joints* Joints::New() const {
  return new Joints;
}

void Joints::Clear() {
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Joints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Joints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double values = 1;
      case 1: {
        if (tag == 9) {
         parse_values:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9, input, this->mutable_values())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(9)) goto parse_values;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Joints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Joints)
  return false;
#undef DO_
}

void Joints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Joints)
  // repeated double values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->values(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Joints)
}

::google::protobuf::uint8* Joints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Joints)
  // repeated double values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(1, this->values(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Joints)
  return target;
}

int Joints::ByteSize() const {
  int total_size = 0;

  // repeated double values = 1;
  {
    int data_size = 0;
    data_size = 8 * this->values_size();
    total_size += 1 * this->values_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Joints::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Joints* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Joints*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Joints::MergeFrom(const Joints& from) {
  GOOGLE_CHECK_NE(&from, this);
  values_.MergeFrom(from.values_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Joints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Joints::CopyFrom(const Joints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Joints::IsInitialized() const {

  return true;
}

void Joints::Swap(Joints* other) {
  if (other != this) {
    values_.Swap(&other->values_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Joints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Joints_descriptor_;
  metadata.reflection = Joints_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JointSpace::kPositionFieldNumber;
const int JointSpace::kVelocityFieldNumber;
#endif  // !_MSC_VER

JointSpace::JointSpace()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.JointSpace)
}

void JointSpace::InitAsDefaultInstance() {
  position_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
  velocity_ = const_cast< ::abb::egm::wrapper::Joints*>(&::abb::egm::wrapper::Joints::default_instance());
}

JointSpace::JointSpace(const JointSpace& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.JointSpace)
}

void JointSpace::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  velocity_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JointSpace::~JointSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.JointSpace)
  SharedDtor();
}

void JointSpace::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete velocity_;
  }
}

void JointSpace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JointSpace::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JointSpace_descriptor_;
}

const JointSpace& JointSpace::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

JointSpace* JointSpace::default_instance_ = NULL;

JointSpace* JointSpace::New() const {
  return new JointSpace;
}

void JointSpace::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_position()) {
      if (position_ != NULL) position_->::abb::egm::wrapper::Joints::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::abb::egm::wrapper::Joints::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JointSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.JointSpace)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_velocity;
        break;
      }

      // optional .abb.egm.wrapper.Joints velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.JointSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.JointSpace)
  return false;
#undef DO_
}

void JointSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.JointSpace)
  // optional .abb.egm.wrapper.Joints position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->position(), output);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->velocity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.JointSpace)
}

::google::protobuf::uint8* JointSpace::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.JointSpace)
  // optional .abb.egm.wrapper.Joints position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->position(), target);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->velocity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.JointSpace)
  return target;
}

int JointSpace::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Joints position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // optional .abb.egm.wrapper.Joints velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JointSpace::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JointSpace* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JointSpace*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JointSpace::MergeFrom(const JointSpace& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::abb::egm::wrapper::Joints::MergeFrom(from.position());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::abb::egm::wrapper::Joints::MergeFrom(from.velocity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JointSpace::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointSpace::CopyFrom(const JointSpace& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointSpace::IsInitialized() const {

  return true;
}

void JointSpace::Swap(JointSpace* other) {
  if (other != this) {
    std::swap(position_, other->position_);
    std::swap(velocity_, other->velocity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JointSpace::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JointSpace_descriptor_;
  metadata.reflection = JointSpace_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Cartesian::kXFieldNumber;
const int Cartesian::kYFieldNumber;
const int Cartesian::kZFieldNumber;
#endif  // !_MSC_VER

Cartesian::Cartesian()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Cartesian)
}

void Cartesian::InitAsDefaultInstance() {
}

Cartesian::Cartesian(const Cartesian& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Cartesian)
}

void Cartesian::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Cartesian)
  SharedDtor();
}

void Cartesian::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Cartesian::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Cartesian::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Cartesian_descriptor_;
}

const Cartesian& Cartesian::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Cartesian* Cartesian::default_instance_ = NULL;

Cartesian* Cartesian::New() const {
  return new Cartesian;
}

void Cartesian::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Cartesian*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Cartesian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Cartesian)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Cartesian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Cartesian)
  return false;
#undef DO_
}

void Cartesian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Cartesian)
  // optional double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Cartesian)
}

::google::protobuf::uint8* Cartesian::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Cartesian)
  // optional double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Cartesian)
  return target;
}

int Cartesian::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Cartesian::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Cartesian* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Cartesian*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Cartesian::MergeFrom(const Cartesian& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Cartesian::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cartesian::CopyFrom(const Cartesian& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {

  return true;
}

void Cartesian::Swap(Cartesian* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Cartesian::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Cartesian_descriptor_;
  metadata.reflection = Cartesian_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Euler::kXFieldNumber;
const int Euler::kYFieldNumber;
const int Euler::kZFieldNumber;
#endif  // !_MSC_VER

Euler::Euler()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Euler)
}

void Euler::InitAsDefaultInstance() {
}

Euler::Euler(const Euler& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Euler)
}

void Euler::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Euler::~Euler() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Euler)
  SharedDtor();
}

void Euler::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Euler::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Euler::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Euler_descriptor_;
}

const Euler& Euler::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Euler* Euler::default_instance_ = NULL;

Euler* Euler::New() const {
  return new Euler;
}

void Euler::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Euler*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Euler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Euler)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Euler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Euler)
  return false;
#undef DO_
}

void Euler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Euler)
  // optional double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Euler)
}

::google::protobuf::uint8* Euler::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Euler)
  // optional double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Euler)
  return target;
}

int Euler::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Euler::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Euler* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Euler*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Euler::MergeFrom(const Euler& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Euler::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Euler::CopyFrom(const Euler& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Euler::IsInitialized() const {

  return true;
}

void Euler::Swap(Euler* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Euler::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Euler_descriptor_;
  metadata.reflection = Euler_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Quaternion::kU0FieldNumber;
const int Quaternion::kU1FieldNumber;
const int Quaternion::kU2FieldNumber;
const int Quaternion::kU3FieldNumber;
#endif  // !_MSC_VER

Quaternion::Quaternion()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Quaternion)
}

void Quaternion::InitAsDefaultInstance() {
}

Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Quaternion)
}

void Quaternion::SharedCtor() {
  _cached_size_ = 0;
  u0_ = 0;
  u1_ = 0;
  u2_ = 0;
  u3_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Quaternion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Quaternion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Quaternion_descriptor_;
}

const Quaternion& Quaternion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Quaternion* Quaternion::default_instance_ = NULL;

Quaternion* Quaternion::New() const {
  return new Quaternion;
}

void Quaternion::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Quaternion*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(u0_, u3_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Quaternion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double u0 = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u0_)));
          set_has_u0();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_u1;
        break;
      }

      // optional double u1 = 2;
      case 2: {
        if (tag == 17) {
         parse_u1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u1_)));
          set_has_u1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_u2;
        break;
      }

      // optional double u2 = 3;
      case 3: {
        if (tag == 25) {
         parse_u2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u2_)));
          set_has_u2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_u3;
        break;
      }

      // optional double u3 = 4;
      case 4: {
        if (tag == 33) {
         parse_u3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u3_)));
          set_has_u3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Quaternion)
  return false;
#undef DO_
}

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Quaternion)
  // optional double u0 = 1;
  if (has_u0()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->u0(), output);
  }

  // optional double u1 = 2;
  if (has_u1()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->u1(), output);
  }

  // optional double u2 = 3;
  if (has_u2()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->u2(), output);
  }

  // optional double u3 = 4;
  if (has_u3()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->u3(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Quaternion)
}

::google::protobuf::uint8* Quaternion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Quaternion)
  // optional double u0 = 1;
  if (has_u0()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->u0(), target);
  }

  // optional double u1 = 2;
  if (has_u1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->u1(), target);
  }

  // optional double u2 = 3;
  if (has_u2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->u2(), target);
  }

  // optional double u3 = 4;
  if (has_u3()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->u3(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Quaternion)
  return target;
}

int Quaternion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double u0 = 1;
    if (has_u0()) {
      total_size += 1 + 8;
    }

    // optional double u1 = 2;
    if (has_u1()) {
      total_size += 1 + 8;
    }

    // optional double u2 = 3;
    if (has_u2()) {
      total_size += 1 + 8;
    }

    // optional double u3 = 4;
    if (has_u3()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Quaternion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Quaternion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_u0()) {
      set_u0(from.u0());
    }
    if (from.has_u1()) {
      set_u1(from.u1());
    }
    if (from.has_u2()) {
      set_u2(from.u2());
    }
    if (from.has_u3()) {
      set_u3(from.u3());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {

  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other != this) {
    std::swap(u0_, other->u0_);
    std::swap(u1_, other->u1_);
    std::swap(u2_, other->u2_);
    std::swap(u3_, other->u3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Quaternion_descriptor_;
  metadata.reflection = Quaternion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CartesianPose::kPositionFieldNumber;
const int CartesianPose::kEulerFieldNumber;
const int CartesianPose::kQuaternionFieldNumber;
#endif  // !_MSC_VER

CartesianPose::CartesianPose()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianPose)
}

void CartesianPose::InitAsDefaultInstance() {
  position_ = const_cast< ::abb::egm::wrapper::Cartesian*>(&::abb::egm::wrapper::Cartesian::default_instance());
  euler_ = const_cast< ::abb::egm::wrapper::Euler*>(&::abb::egm::wrapper::Euler::default_instance());
  quaternion_ = const_cast< ::abb::egm::wrapper::Quaternion*>(&::abb::egm::wrapper::Quaternion::default_instance());
}

CartesianPose::CartesianPose(const CartesianPose& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianPose)
}

void CartesianPose::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  euler_ = NULL;
  quaternion_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CartesianPose::~CartesianPose() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianPose)
  SharedDtor();
}

void CartesianPose::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete euler_;
    delete quaternion_;
  }
}

void CartesianPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartesianPose_descriptor_;
}

const CartesianPose& CartesianPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

CartesianPose* CartesianPose::default_instance_ = NULL;

CartesianPose* CartesianPose::New() const {
  return new CartesianPose;
}

void CartesianPose::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_position()) {
      if (position_ != NULL) position_->::abb::egm::wrapper::Cartesian::Clear();
    }
    if (has_euler()) {
      if (euler_ != NULL) euler_->::abb::egm::wrapper::Euler::Clear();
    }
    if (has_quaternion()) {
      if (quaternion_ != NULL) quaternion_->::abb::egm::wrapper::Quaternion::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CartesianPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_euler;
        break;
      }

      // optional .abb.egm.wrapper.Euler euler = 2;
      case 2: {
        if (tag == 18) {
         parse_euler:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_euler()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_quaternion;
        break;
      }

      // optional .abb.egm.wrapper.Quaternion quaternion = 3;
      case 3: {
        if (tag == 26) {
         parse_quaternion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_quaternion()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianPose)
  return false;
#undef DO_
}

void CartesianPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianPose)
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->position(), output);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (has_euler()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->euler(), output);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (has_quaternion()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->quaternion(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianPose)
}

::google::protobuf::uint8* CartesianPose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianPose)
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->position(), target);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (has_euler()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->euler(), target);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (has_quaternion()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->quaternion(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianPose)
  return target;
}

int CartesianPose::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Cartesian position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // optional .abb.egm.wrapper.Euler euler = 2;
    if (has_euler()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->euler());
    }

    // optional .abb.egm.wrapper.Quaternion quaternion = 3;
    if (has_quaternion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->quaternion());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianPose::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CartesianPose* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CartesianPose*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CartesianPose::MergeFrom(const CartesianPose& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::abb::egm::wrapper::Cartesian::MergeFrom(from.position());
    }
    if (from.has_euler()) {
      mutable_euler()->::abb::egm::wrapper::Euler::MergeFrom(from.euler());
    }
    if (from.has_quaternion()) {
      mutable_quaternion()->::abb::egm::wrapper::Quaternion::MergeFrom(from.quaternion());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CartesianPose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianPose::CopyFrom(const CartesianPose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianPose::IsInitialized() const {

  return true;
}

void CartesianPose::Swap(CartesianPose* other) {
  if (other != this) {
    std::swap(position_, other->position_);
    std::swap(euler_, other->euler_);
    std::swap(quaternion_, other->quaternion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CartesianPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CartesianPose_descriptor_;
  metadata.reflection = CartesianPose_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CartesianVelocity::kLinearFieldNumber;
const int CartesianVelocity::kAngularFieldNumber;
#endif  // !_MSC_VER

CartesianVelocity::CartesianVelocity()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianVelocity)
}

void CartesianVelocity::InitAsDefaultInstance() {
  linear_ = const_cast< ::abb::egm::wrapper::Cartesian*>(&::abb::egm::wrapper::Cartesian::default_instance());
  angular_ = const_cast< ::abb::egm::wrapper::Euler*>(&::abb::egm::wrapper::Euler::default_instance());
}

CartesianVelocity::CartesianVelocity(const CartesianVelocity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianVelocity)
}

void CartesianVelocity::SharedCtor() {
  _cached_size_ = 0;
  linear_ = NULL;
  angular_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CartesianVelocity::~CartesianVelocity() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianVelocity)
  SharedDtor();
}

void CartesianVelocity::SharedDtor() {
  if (this != default_instance_) {
    delete linear_;
    delete angular_;
  }
}

void CartesianVelocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianVelocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartesianVelocity_descriptor_;
}

const CartesianVelocity& CartesianVelocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

CartesianVelocity* CartesianVelocity::default_instance_ = NULL;

CartesianVelocity* CartesianVelocity::New() const {
  return new CartesianVelocity;
}

void CartesianVelocity::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_linear()) {
      if (linear_ != NULL) linear_->::abb::egm::wrapper::Cartesian::Clear();
    }
    if (has_angular()) {
      if (angular_ != NULL) angular_->::abb::egm::wrapper::Euler::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CartesianVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianVelocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian linear = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linear()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angular;
        break;
      }

      // optional .abb.egm.wrapper.Euler angular = 2;
      case 2: {
        if (tag == 18) {
         parse_angular:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angular()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianVelocity)
  return false;
#undef DO_
}

void CartesianVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianVelocity)
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (has_linear()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->linear(), output);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (has_angular()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->angular(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianVelocity)
}

::google::protobuf::uint8* CartesianVelocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianVelocity)
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (has_linear()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->linear(), target);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (has_angular()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->angular(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianVelocity)
  return target;
}

int CartesianVelocity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Cartesian linear = 1;
    if (has_linear()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->linear());
    }

    // optional .abb.egm.wrapper.Euler angular = 2;
    if (has_angular()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->angular());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianVelocity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CartesianVelocity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CartesianVelocity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CartesianVelocity::MergeFrom(const CartesianVelocity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_linear()) {
      mutable_linear()->::abb::egm::wrapper::Cartesian::MergeFrom(from.linear());
    }
    if (from.has_angular()) {
      mutable_angular()->::abb::egm::wrapper::Euler::MergeFrom(from.angular());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CartesianVelocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianVelocity::CopyFrom(const CartesianVelocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianVelocity::IsInitialized() const {

  return true;
}

void CartesianVelocity::Swap(CartesianVelocity* other) {
  if (other != this) {
    std::swap(linear_, other->linear_);
    std::swap(angular_, other->angular_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CartesianVelocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CartesianVelocity_descriptor_;
  metadata.reflection = CartesianVelocity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CartesianSpace::kPoseFieldNumber;
const int CartesianSpace::kVelocityFieldNumber;
#endif  // !_MSC_VER

CartesianSpace::CartesianSpace()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianSpace)
}

void CartesianSpace::InitAsDefaultInstance() {
  pose_ = const_cast< ::abb::egm::wrapper::CartesianPose*>(&::abb::egm::wrapper::CartesianPose::default_instance());
  velocity_ = const_cast< ::abb::egm::wrapper::CartesianVelocity*>(&::abb::egm::wrapper::CartesianVelocity::default_instance());
}

CartesianSpace::CartesianSpace(const CartesianSpace& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianSpace)
}

void CartesianSpace::SharedCtor() {
  _cached_size_ = 0;
  pose_ = NULL;
  velocity_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CartesianSpace::~CartesianSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianSpace)
  SharedDtor();
}

void CartesianSpace::SharedDtor() {
  if (this != default_instance_) {
    delete pose_;
    delete velocity_;
  }
}

void CartesianSpace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartesianSpace::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartesianSpace_descriptor_;
}

const CartesianSpace& CartesianSpace::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

CartesianSpace* CartesianSpace::default_instance_ = NULL;

CartesianSpace* CartesianSpace::New() const {
  return new CartesianSpace;
}

void CartesianSpace::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_pose()) {
      if (pose_ != NULL) pose_->::abb::egm::wrapper::CartesianPose::Clear();
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::abb::egm::wrapper::CartesianVelocity::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CartesianSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianSpace)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.CartesianPose pose = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_velocity;
        break;
      }

      // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianSpace)
  return false;
#undef DO_
}

void CartesianSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianSpace)
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pose(), output);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->velocity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianSpace)
}

::google::protobuf::uint8* CartesianSpace::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianSpace)
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pose(), target);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->velocity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianSpace)
  return target;
}

int CartesianSpace::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.CartesianPose pose = 1;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pose());
    }

    // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
    if (has_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->velocity());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartesianSpace::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CartesianSpace* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CartesianSpace*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CartesianSpace::MergeFrom(const CartesianSpace& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pose()) {
      mutable_pose()->::abb::egm::wrapper::CartesianPose::MergeFrom(from.pose());
    }
    if (from.has_velocity()) {
      mutable_velocity()->::abb::egm::wrapper::CartesianVelocity::MergeFrom(from.velocity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CartesianSpace::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianSpace::CopyFrom(const CartesianSpace& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianSpace::IsInitialized() const {

  return true;
}

void CartesianSpace::Swap(CartesianSpace* other) {
  if (other != this) {
    std::swap(pose_, other->pose_);
    std::swap(velocity_, other->velocity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CartesianSpace::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CartesianSpace_descriptor_;
  metadata.reflection = CartesianSpace_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Robot::kJointsFieldNumber;
const int Robot::kCartesianFieldNumber;
#endif  // !_MSC_VER

Robot::Robot()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Robot)
}

void Robot::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(&::abb::egm::wrapper::JointSpace::default_instance());
  cartesian_ = const_cast< ::abb::egm::wrapper::CartesianSpace*>(&::abb::egm::wrapper::CartesianSpace::default_instance());
}

Robot::Robot(const Robot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Robot)
}

void Robot::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  cartesian_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Robot)
  SharedDtor();
}

void Robot::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
    delete cartesian_;
  }
}

void Robot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Robot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Robot_descriptor_;
}

const Robot& Robot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Robot* Robot::default_instance_ = NULL;

Robot* Robot::New() const {
  return new Robot;
}

void Robot::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_joints()) {
      if (joints_ != NULL) joints_->::abb::egm::wrapper::JointSpace::Clear();
    }
    if (has_cartesian()) {
      if (cartesian_ != NULL) cartesian_->::abb::egm::wrapper::CartesianSpace::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Robot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Robot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cartesian;
        break;
      }

      // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
      case 2: {
        if (tag == 18) {
         parse_cartesian:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Robot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Robot)
  return false;
#undef DO_
}

void Robot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Robot)
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (has_cartesian()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->cartesian(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Robot)
}

::google::protobuf::uint8* Robot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Robot)
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (has_cartesian()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->cartesian(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Robot)
  return target;
}

int Robot::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.JointSpace joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

    // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cartesian());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Robot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Robot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Robot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
    }
    if (from.has_cartesian()) {
      mutable_cartesian()->::abb::egm::wrapper::CartesianSpace::MergeFrom(from.cartesian());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Robot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {

  return true;
}

void Robot::Swap(Robot* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(cartesian_, other->cartesian_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Robot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Robot_descriptor_;
  metadata.reflection = Robot_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int External::kJointsFieldNumber;
#endif  // !_MSC_VER

External::External()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.External)
}

void External::InitAsDefaultInstance() {
  joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(&::abb::egm::wrapper::JointSpace::default_instance());
}

External::External(const External& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.External)
}

void External::SharedCtor() {
  _cached_size_ = 0;
  joints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

External::~External() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.External)
  SharedDtor();
}

void External::SharedDtor() {
  if (this != default_instance_) {
    delete joints_;
  }
}

void External::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* External::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return External_descriptor_;
}

const External& External::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

External* External::default_instance_ = NULL;

External* External::New() const {
  return new External;
}

void External::Clear() {
  if (has_joints()) {
    if (joints_ != NULL) joints_->::abb::egm::wrapper::JointSpace::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool External::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.External)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.External)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.External)
  return false;
#undef DO_
}

void External::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.External)
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->joints(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.External)
}

::google::protobuf::uint8* External::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.External)
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->joints(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.External)
  return target;
}

int External::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.JointSpace joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joints());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void External::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const External* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const External*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void External::MergeFrom(const External& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_joints()) {
      mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void External::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void External::CopyFrom(const External& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool External::IsInitialized() const {

  return true;
}

void External::Swap(External* other) {
  if (other != this) {
    std::swap(joints_, other->joints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata External::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = External_descriptor_;
  metadata.reflection = External_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Feedback::kRobotFieldNumber;
const int Feedback::kExternalFieldNumber;
const int Feedback::kTimeFieldNumber;
#endif  // !_MSC_VER

Feedback::Feedback()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Feedback)
}

void Feedback::InitAsDefaultInstance() {
  robot_ = const_cast< ::abb::egm::wrapper::Robot*>(&::abb::egm::wrapper::Robot::default_instance());
  external_ = const_cast< ::abb::egm::wrapper::External*>(&::abb::egm::wrapper::External::default_instance());
  time_ = const_cast< ::abb::egm::wrapper::Clock*>(&::abb::egm::wrapper::Clock::default_instance());
}

Feedback::Feedback(const Feedback& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Feedback)
}

void Feedback::SharedCtor() {
  _cached_size_ = 0;
  robot_ = NULL;
  external_ = NULL;
  time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Feedback::~Feedback() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Feedback)
  SharedDtor();
}

void Feedback::SharedDtor() {
  if (this != default_instance_) {
    delete robot_;
    delete external_;
    delete time_;
  }
}

void Feedback::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Feedback::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Feedback_descriptor_;
}

const Feedback& Feedback::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Feedback* Feedback::default_instance_ = NULL;

Feedback* Feedback::New() const {
  return new Feedback;
}

void Feedback::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_robot()) {
      if (robot_ != NULL) robot_->::abb::egm::wrapper::Robot::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::abb::egm::wrapper::External::Clear();
    }
    if (has_time()) {
      if (time_ != NULL) time_->::abb::egm::wrapper::Clock::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Feedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Feedback)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_external;
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (tag == 18) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_time;
        break;
      }

      // optional .abb.egm.wrapper.Clock time = 3;
      case 3: {
        if (tag == 26) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Feedback)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Feedback)
  return false;
#undef DO_
}

void Feedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Feedback)
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->robot(), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->external(), output);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Feedback)
}

::google::protobuf::uint8* Feedback::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Feedback)
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->robot(), target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->external(), target);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Feedback)
  return target;
}

int Feedback::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot());
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

    // optional .abb.egm.wrapper.Clock time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Feedback::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Feedback* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Feedback*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Feedback::MergeFrom(const Feedback& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robot()) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (from.has_external()) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
    if (from.has_time()) {
      mutable_time()->::abb::egm::wrapper::Clock::MergeFrom(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Feedback::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Feedback::CopyFrom(const Feedback& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Feedback::IsInitialized() const {

  return true;
}

void Feedback::Swap(Feedback* other) {
  if (other != this) {
    std::swap(robot_, other->robot_);
    std::swap(external_, other->external_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Feedback::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Feedback_descriptor_;
  metadata.reflection = Feedback_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Planned::kRobotFieldNumber;
const int Planned::kExternalFieldNumber;
const int Planned::kTimeFieldNumber;
#endif  // !_MSC_VER

Planned::Planned()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Planned)
}

void Planned::InitAsDefaultInstance() {
  robot_ = const_cast< ::abb::egm::wrapper::Robot*>(&::abb::egm::wrapper::Robot::default_instance());
  external_ = const_cast< ::abb::egm::wrapper::External*>(&::abb::egm::wrapper::External::default_instance());
  time_ = const_cast< ::abb::egm::wrapper::Clock*>(&::abb::egm::wrapper::Clock::default_instance());
}

Planned::Planned(const Planned& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Planned)
}

void Planned::SharedCtor() {
  _cached_size_ = 0;
  robot_ = NULL;
  external_ = NULL;
  time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Planned::~Planned() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Planned)
  SharedDtor();
}

void Planned::SharedDtor() {
  if (this != default_instance_) {
    delete robot_;
    delete external_;
    delete time_;
  }
}

void Planned::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Planned::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Planned_descriptor_;
}

const Planned& Planned::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Planned* Planned::default_instance_ = NULL;

Planned* Planned::New() const {
  return new Planned;
}

void Planned::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_robot()) {
      if (robot_ != NULL) robot_->::abb::egm::wrapper::Robot::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::abb::egm::wrapper::External::Clear();
    }
    if (has_time()) {
      if (time_ != NULL) time_->::abb::egm::wrapper::Clock::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Planned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Planned)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_external;
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (tag == 18) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_time;
        break;
      }

      // optional .abb.egm.wrapper.Clock time = 3;
      case 3: {
        if (tag == 26) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Planned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Planned)
  return false;
#undef DO_
}

void Planned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Planned)
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->robot(), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->external(), output);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Planned)
}

::google::protobuf::uint8* Planned::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Planned)
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->robot(), target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->external(), target);
  }

  // optional .abb.egm.wrapper.Clock time = 3;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Planned)
  return target;
}

int Planned::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot());
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

    // optional .abb.egm.wrapper.Clock time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Planned::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Planned* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Planned*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Planned::MergeFrom(const Planned& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robot()) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (from.has_external()) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
    if (from.has_time()) {
      mutable_time()->::abb::egm::wrapper::Clock::MergeFrom(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Planned::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Planned::CopyFrom(const Planned& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Planned::IsInitialized() const {

  return true;
}

void Planned::Swap(Planned* other) {
  if (other != this) {
    std::swap(robot_, other->robot_);
    std::swap(external_, other->external_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Planned::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Planned_descriptor_;
  metadata.reflection = Planned_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Input::kHeaderFieldNumber;
const int Input::kFeedbackFieldNumber;
const int Input::kPlannedFieldNumber;
const int Input::kStatusFieldNumber;
#endif  // !_MSC_VER

Input::Input()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Input)
}

void Input::InitAsDefaultInstance() {
  header_ = const_cast< ::abb::egm::wrapper::Header*>(&::abb::egm::wrapper::Header::default_instance());
  feedback_ = const_cast< ::abb::egm::wrapper::Feedback*>(&::abb::egm::wrapper::Feedback::default_instance());
  planned_ = const_cast< ::abb::egm::wrapper::Planned*>(&::abb::egm::wrapper::Planned::default_instance());
  status_ = const_cast< ::abb::egm::wrapper::Status*>(&::abb::egm::wrapper::Status::default_instance());
}

Input::Input(const Input& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Input)
}

void Input::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  feedback_ = NULL;
  planned_ = NULL;
  status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Input::~Input() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Input)
  SharedDtor();
}

void Input::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete feedback_;
    delete planned_;
    delete status_;
  }
}

void Input::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Input::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Input_descriptor_;
}

const Input& Input::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Input* Input::default_instance_ = NULL;

Input* Input::New() const {
  return new Input;
}

void Input::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_header()) {
      if (header_ != NULL) header_->::abb::egm::wrapper::Header::Clear();
    }
    if (has_feedback()) {
      if (feedback_ != NULL) feedback_->::abb::egm::wrapper::Feedback::Clear();
    }
    if (has_planned()) {
      if (planned_ != NULL) planned_->::abb::egm::wrapper::Planned::Clear();
    }
    if (has_status()) {
      if (status_ != NULL) status_->::abb::egm::wrapper::Status::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Input::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Input)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Header header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_feedback;
        break;
      }

      // optional .abb.egm.wrapper.Feedback feedback = 2;
      case 2: {
        if (tag == 18) {
         parse_feedback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_feedback()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_planned;
        break;
      }

      // optional .abb.egm.wrapper.Planned planned = 3;
      case 3: {
        if (tag == 26) {
         parse_planned:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_status;
        break;
      }

      // optional .abb.egm.wrapper.Status status = 4;
      case 4: {
        if (tag == 34) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Input)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Input)
  return false;
#undef DO_
}

void Input::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Input)
  // optional .abb.egm.wrapper.Header header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (has_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->feedback(), output);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (has_planned()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->planned(), output);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Input)
}

::google::protobuf::uint8* Input::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Input)
  // optional .abb.egm.wrapper.Header header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (has_feedback()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->feedback(), target);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (has_planned()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->planned(), target);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Input)
  return target;
}

int Input::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Header header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional .abb.egm.wrapper.Feedback feedback = 2;
    if (has_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->feedback());
    }

    // optional .abb.egm.wrapper.Planned planned = 3;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->planned());
    }

    // optional .abb.egm.wrapper.Status status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Input::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Input* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Input*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Input::MergeFrom(const Input& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::abb::egm::wrapper::Header::MergeFrom(from.header());
    }
    if (from.has_feedback()) {
      mutable_feedback()->::abb::egm::wrapper::Feedback::MergeFrom(from.feedback());
    }
    if (from.has_planned()) {
      mutable_planned()->::abb::egm::wrapper::Planned::MergeFrom(from.planned());
    }
    if (from.has_status()) {
      mutable_status()->::abb::egm::wrapper::Status::MergeFrom(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Input::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Input::CopyFrom(const Input& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Input::IsInitialized() const {

  return true;
}

void Input::Swap(Input* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(feedback_, other->feedback_);
    std::swap(planned_, other->planned_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Input::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Input_descriptor_;
  metadata.reflection = Input_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Output::kRobotFieldNumber;
const int Output::kExternalFieldNumber;
#endif  // !_MSC_VER

Output::Output()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Output)
}

void Output::InitAsDefaultInstance() {
  robot_ = const_cast< ::abb::egm::wrapper::Robot*>(&::abb::egm::wrapper::Robot::default_instance());
  external_ = const_cast< ::abb::egm::wrapper::External*>(&::abb::egm::wrapper::External::default_instance());
}

Output::Output(const Output& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Output)
}

void Output::SharedCtor() {
  _cached_size_ = 0;
  robot_ = NULL;
  external_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Output::~Output() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Output)
  SharedDtor();
}

void Output::SharedDtor() {
  if (this != default_instance_) {
    delete robot_;
    delete external_;
  }
}

void Output::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Output::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Output_descriptor_;
}

const Output& Output::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_egm_5fwrapper_2eproto();
  return *default_instance_;
}

Output* Output::default_instance_ = NULL;

Output* Output::New() const {
  return new Output;
}

void Output::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_robot()) {
      if (robot_ != NULL) robot_->::abb::egm::wrapper::Robot::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::abb::egm::wrapper::External::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Output::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Output)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_external;
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (tag == 18) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Output)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Output)
  return false;
#undef DO_
}

void Output::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Output)
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (has_robot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->robot(), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->external(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Output)
}

::google::protobuf::uint8* Output::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Output)
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (has_robot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->robot(), target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->external(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Output)
  return target;
}

int Output::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (has_robot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot());
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Output::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Output* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Output*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Output::MergeFrom(const Output& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robot()) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (from.has_external()) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Output::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Output::CopyFrom(const Output& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Output::IsInitialized() const {

  return true;
}

void Output::Swap(Output* other) {
  if (other != this) {
    std::swap(robot_, other->robot_);
    std::swap(external_, other->external_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Output::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Output_descriptor_;
  metadata.reflection = Output_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wrapper
}  // namespace egm
}  // namespace abb

// @@protoc_insertion_point(global_scope)
