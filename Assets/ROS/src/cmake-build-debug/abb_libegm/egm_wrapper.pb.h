// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#ifndef PROTOBUF_egm_5fwrapper_2eproto__INCLUDED
#define PROTOBUF_egm_5fwrapper_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace abb {
namespace egm {
namespace wrapper {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_egm_5fwrapper_2eproto();
void protobuf_AssignDesc_egm_5fwrapper_2eproto();
void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

class Header;
class Status;
class Clock;
class Joints;
class JointSpace;
class Cartesian;
class Euler;
class Quaternion;
class CartesianPose;
class CartesianVelocity;
class CartesianSpace;
class Robot;
class External;
class Feedback;
class Planned;
class Input;
class Output;

enum Header_MessageType {
  Header_MessageType_UNDEFINED = 0,
  Header_MessageType_DATA = 1
};
bool Header_MessageType_IsValid(int value);
const Header_MessageType Header_MessageType_MessageType_MIN = Header_MessageType_UNDEFINED;
const Header_MessageType Header_MessageType_MessageType_MAX = Header_MessageType_DATA;
const int Header_MessageType_MessageType_ARRAYSIZE = Header_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor();
inline const ::std::string& Header_MessageType_Name(Header_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_MessageType_descriptor(), value);
}
inline bool Header_MessageType_Parse(
    const ::std::string& name, Header_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_MessageType>(
    Header_MessageType_descriptor(), name, value);
}
enum Status_EGMState {
  Status_EGMState_EGM_UNDEFINED = 0,
  Status_EGMState_EGM_ERROR = 1,
  Status_EGMState_EGM_STOPPED = 2,
  Status_EGMState_EGM_RUNNING = 3
};
bool Status_EGMState_IsValid(int value);
const Status_EGMState Status_EGMState_EGMState_MIN = Status_EGMState_EGM_UNDEFINED;
const Status_EGMState Status_EGMState_EGMState_MAX = Status_EGMState_EGM_RUNNING;
const int Status_EGMState_EGMState_ARRAYSIZE = Status_EGMState_EGMState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor();
inline const ::std::string& Status_EGMState_Name(Status_EGMState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_EGMState_descriptor(), value);
}
inline bool Status_EGMState_Parse(
    const ::std::string& name, Status_EGMState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_EGMState>(
    Status_EGMState_descriptor(), name, value);
}
enum Status_MotorState {
  Status_MotorState_MOTORS_UNDEFINED = 0,
  Status_MotorState_MOTORS_ON = 1,
  Status_MotorState_MOTORS_OFF = 2
};
bool Status_MotorState_IsValid(int value);
const Status_MotorState Status_MotorState_MotorState_MIN = Status_MotorState_MOTORS_UNDEFINED;
const Status_MotorState Status_MotorState_MotorState_MAX = Status_MotorState_MOTORS_OFF;
const int Status_MotorState_MotorState_ARRAYSIZE = Status_MotorState_MotorState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor();
inline const ::std::string& Status_MotorState_Name(Status_MotorState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_MotorState_descriptor(), value);
}
inline bool Status_MotorState_Parse(
    const ::std::string& name, Status_MotorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_MotorState>(
    Status_MotorState_descriptor(), name, value);
}
enum Status_RAPIDExecutionState {
  Status_RAPIDExecutionState_RAPID_UNDEFINED = 0,
  Status_RAPIDExecutionState_RAPID_STOPPED = 1,
  Status_RAPIDExecutionState_RAPID_RUNNING = 2
};
bool Status_RAPIDExecutionState_IsValid(int value);
const Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MIN = Status_RAPIDExecutionState_RAPID_UNDEFINED;
const Status_RAPIDExecutionState Status_RAPIDExecutionState_RAPIDExecutionState_MAX = Status_RAPIDExecutionState_RAPID_RUNNING;
const int Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE = Status_RAPIDExecutionState_RAPIDExecutionState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor();
inline const ::std::string& Status_RAPIDExecutionState_Name(Status_RAPIDExecutionState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_RAPIDExecutionState_descriptor(), value);
}
inline bool Status_RAPIDExecutionState_Parse(
    const ::std::string& name, Status_RAPIDExecutionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_RAPIDExecutionState>(
    Status_RAPIDExecutionState_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Header_MessageType MessageType;
  static const MessageType UNDEFINED = Header_MessageType_UNDEFINED;
  static const MessageType DATA = Header_MessageType_DATA;
  static inline bool MessageType_IsValid(int value) {
    return Header_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Header_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Header_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Header_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Header_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Header_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Header_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 sequence_number = 1;
  inline bool has_sequence_number() const;
  inline void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 sequence_number() const;
  inline void set_sequence_number(::google::protobuf::uint32 value);

  // optional uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 3;
  inline ::abb::egm::wrapper::Header_MessageType message_type() const;
  inline void set_message_type(::abb::egm::wrapper::Header_MessageType value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Header)
 private:
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_message_type();
  inline void clear_has_message_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sequence_number_;
  ::google::protobuf::uint32 time_stamp_;
  int message_type_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Status_EGMState EGMState;
  static const EGMState EGM_UNDEFINED = Status_EGMState_EGM_UNDEFINED;
  static const EGMState EGM_ERROR = Status_EGMState_EGM_ERROR;
  static const EGMState EGM_STOPPED = Status_EGMState_EGM_STOPPED;
  static const EGMState EGM_RUNNING = Status_EGMState_EGM_RUNNING;
  static inline bool EGMState_IsValid(int value) {
    return Status_EGMState_IsValid(value);
  }
  static const EGMState EGMState_MIN =
    Status_EGMState_EGMState_MIN;
  static const EGMState EGMState_MAX =
    Status_EGMState_EGMState_MAX;
  static const int EGMState_ARRAYSIZE =
    Status_EGMState_EGMState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGMState_descriptor() {
    return Status_EGMState_descriptor();
  }
  static inline const ::std::string& EGMState_Name(EGMState value) {
    return Status_EGMState_Name(value);
  }
  static inline bool EGMState_Parse(const ::std::string& name,
      EGMState* value) {
    return Status_EGMState_Parse(name, value);
  }

  typedef Status_MotorState MotorState;
  static const MotorState MOTORS_UNDEFINED = Status_MotorState_MOTORS_UNDEFINED;
  static const MotorState MOTORS_ON = Status_MotorState_MOTORS_ON;
  static const MotorState MOTORS_OFF = Status_MotorState_MOTORS_OFF;
  static inline bool MotorState_IsValid(int value) {
    return Status_MotorState_IsValid(value);
  }
  static const MotorState MotorState_MIN =
    Status_MotorState_MotorState_MIN;
  static const MotorState MotorState_MAX =
    Status_MotorState_MotorState_MAX;
  static const int MotorState_ARRAYSIZE =
    Status_MotorState_MotorState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotorState_descriptor() {
    return Status_MotorState_descriptor();
  }
  static inline const ::std::string& MotorState_Name(MotorState value) {
    return Status_MotorState_Name(value);
  }
  static inline bool MotorState_Parse(const ::std::string& name,
      MotorState* value) {
    return Status_MotorState_Parse(name, value);
  }

  typedef Status_RAPIDExecutionState RAPIDExecutionState;
  static const RAPIDExecutionState RAPID_UNDEFINED = Status_RAPIDExecutionState_RAPID_UNDEFINED;
  static const RAPIDExecutionState RAPID_STOPPED = Status_RAPIDExecutionState_RAPID_STOPPED;
  static const RAPIDExecutionState RAPID_RUNNING = Status_RAPIDExecutionState_RAPID_RUNNING;
  static inline bool RAPIDExecutionState_IsValid(int value) {
    return Status_RAPIDExecutionState_IsValid(value);
  }
  static const RAPIDExecutionState RAPIDExecutionState_MIN =
    Status_RAPIDExecutionState_RAPIDExecutionState_MIN;
  static const RAPIDExecutionState RAPIDExecutionState_MAX =
    Status_RAPIDExecutionState_RAPIDExecutionState_MAX;
  static const int RAPIDExecutionState_ARRAYSIZE =
    Status_RAPIDExecutionState_RAPIDExecutionState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RAPIDExecutionState_descriptor() {
    return Status_RAPIDExecutionState_descriptor();
  }
  static inline const ::std::string& RAPIDExecutionState_Name(RAPIDExecutionState value) {
    return Status_RAPIDExecutionState_Name(value);
  }
  static inline bool RAPIDExecutionState_Parse(const ::std::string& name,
      RAPIDExecutionState* value) {
    return Status_RAPIDExecutionState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool egm_convergence_met = 1;
  inline bool has_egm_convergence_met() const;
  inline void clear_egm_convergence_met();
  static const int kEgmConvergenceMetFieldNumber = 1;
  inline bool egm_convergence_met() const;
  inline void set_egm_convergence_met(bool value);

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  inline bool has_egm_state() const;
  inline void clear_egm_state();
  static const int kEgmStateFieldNumber = 2;
  inline ::abb::egm::wrapper::Status_EGMState egm_state() const;
  inline void set_egm_state(::abb::egm::wrapper::Status_EGMState value);

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  inline bool has_motor_state() const;
  inline void clear_motor_state();
  static const int kMotorStateFieldNumber = 3;
  inline ::abb::egm::wrapper::Status_MotorState motor_state() const;
  inline void set_motor_state(::abb::egm::wrapper::Status_MotorState value);

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  inline bool has_rapid_execution_state() const;
  inline void clear_rapid_execution_state();
  static const int kRapidExecutionStateFieldNumber = 4;
  inline ::abb::egm::wrapper::Status_RAPIDExecutionState rapid_execution_state() const;
  inline void set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Status)
 private:
  inline void set_has_egm_convergence_met();
  inline void clear_has_egm_convergence_met();
  inline void set_has_egm_state();
  inline void clear_has_egm_state();
  inline void set_has_motor_state();
  inline void clear_has_motor_state();
  inline void set_has_rapid_execution_state();
  inline void clear_has_rapid_execution_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool egm_convergence_met_;
  int egm_state_;
  int motor_state_;
  int rapid_execution_state_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class Clock : public ::google::protobuf::Message {
 public:
  Clock();
  virtual ~Clock();

  Clock(const Clock& from);

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clock& default_instance();

  void Swap(Clock* other);

  // implements Message ----------------------------------------------

  Clock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clock& from);
  void MergeFrom(const Clock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 sec = 1;
  inline bool has_sec() const;
  inline void clear_sec();
  static const int kSecFieldNumber = 1;
  inline ::google::protobuf::uint64 sec() const;
  inline void set_sec(::google::protobuf::uint64 value);

  // optional uint64 usec = 2;
  inline bool has_usec() const;
  inline void clear_usec();
  static const int kUsecFieldNumber = 2;
  inline ::google::protobuf::uint64 usec() const;
  inline void set_usec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Clock)
 private:
  inline void set_has_sec();
  inline void clear_has_sec();
  inline void set_has_usec();
  inline void clear_has_usec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sec_;
  ::google::protobuf::uint64 usec_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Clock* default_instance_;
};
// -------------------------------------------------------------------

class Joints : public ::google::protobuf::Message {
 public:
  Joints();
  virtual ~Joints();

  Joints(const Joints& from);

  inline Joints& operator=(const Joints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Joints& default_instance();

  void Swap(Joints* other);

  // implements Message ----------------------------------------------

  Joints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Joints& from);
  void MergeFrom(const Joints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline double values(int index) const;
  inline void set_values(int index, double value);
  inline void add_values(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      values() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Joints)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > values_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Joints* default_instance_;
};
// -------------------------------------------------------------------

class JointSpace : public ::google::protobuf::Message {
 public:
  JointSpace();
  virtual ~JointSpace();

  JointSpace(const JointSpace& from);

  inline JointSpace& operator=(const JointSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointSpace& default_instance();

  void Swap(JointSpace* other);

  // implements Message ----------------------------------------------

  JointSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JointSpace& from);
  void MergeFrom(const JointSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Joints position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::abb::egm::wrapper::Joints& position() const;
  inline ::abb::egm::wrapper::Joints* mutable_position();
  inline ::abb::egm::wrapper::Joints* release_position();
  inline void set_allocated_position(::abb::egm::wrapper::Joints* position);

  // optional .abb.egm.wrapper.Joints velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline const ::abb::egm::wrapper::Joints& velocity() const;
  inline ::abb::egm::wrapper::Joints* mutable_velocity();
  inline ::abb::egm::wrapper::Joints* release_velocity();
  inline void set_allocated_velocity(::abb::egm::wrapper::Joints* velocity);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.JointSpace)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Joints* position_;
  ::abb::egm::wrapper::Joints* velocity_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static JointSpace* default_instance_;
};
// -------------------------------------------------------------------

class Cartesian : public ::google::protobuf::Message {
 public:
  Cartesian();
  virtual ~Cartesian();

  Cartesian(const Cartesian& from);

  inline Cartesian& operator=(const Cartesian& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cartesian& default_instance();

  void Swap(Cartesian* other);

  // implements Message ----------------------------------------------

  Cartesian* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cartesian& from);
  void MergeFrom(const Cartesian& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Cartesian)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Cartesian* default_instance_;
};
// -------------------------------------------------------------------

class Euler : public ::google::protobuf::Message {
 public:
  Euler();
  virtual ~Euler();

  Euler(const Euler& from);

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Euler& default_instance();

  void Swap(Euler* other);

  // implements Message ----------------------------------------------

  Euler* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Euler)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Euler* default_instance_;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  Quaternion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double u0 = 1;
  inline bool has_u0() const;
  inline void clear_u0();
  static const int kU0FieldNumber = 1;
  inline double u0() const;
  inline void set_u0(double value);

  // optional double u1 = 2;
  inline bool has_u1() const;
  inline void clear_u1();
  static const int kU1FieldNumber = 2;
  inline double u1() const;
  inline void set_u1(double value);

  // optional double u2 = 3;
  inline bool has_u2() const;
  inline void clear_u2();
  static const int kU2FieldNumber = 3;
  inline double u2() const;
  inline void set_u2(double value);

  // optional double u3 = 4;
  inline bool has_u3() const;
  inline void clear_u3();
  static const int kU3FieldNumber = 4;
  inline double u3() const;
  inline void set_u3(double value);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Quaternion)
 private:
  inline void set_has_u0();
  inline void clear_has_u0();
  inline void set_has_u1();
  inline void clear_has_u1();
  inline void set_has_u2();
  inline void clear_has_u2();
  inline void set_has_u3();
  inline void clear_has_u3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double u0_;
  double u1_;
  double u2_;
  double u3_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Quaternion* default_instance_;
};
// -------------------------------------------------------------------

class CartesianPose : public ::google::protobuf::Message {
 public:
  CartesianPose();
  virtual ~CartesianPose();

  CartesianPose(const CartesianPose& from);

  inline CartesianPose& operator=(const CartesianPose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianPose& default_instance();

  void Swap(CartesianPose* other);

  // implements Message ----------------------------------------------

  CartesianPose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CartesianPose& from);
  void MergeFrom(const CartesianPose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Cartesian position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::abb::egm::wrapper::Cartesian& position() const;
  inline ::abb::egm::wrapper::Cartesian* mutable_position();
  inline ::abb::egm::wrapper::Cartesian* release_position();
  inline void set_allocated_position(::abb::egm::wrapper::Cartesian* position);

  // optional .abb.egm.wrapper.Euler euler = 2;
  inline bool has_euler() const;
  inline void clear_euler();
  static const int kEulerFieldNumber = 2;
  inline const ::abb::egm::wrapper::Euler& euler() const;
  inline ::abb::egm::wrapper::Euler* mutable_euler();
  inline ::abb::egm::wrapper::Euler* release_euler();
  inline void set_allocated_euler(::abb::egm::wrapper::Euler* euler);

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  inline bool has_quaternion() const;
  inline void clear_quaternion();
  static const int kQuaternionFieldNumber = 3;
  inline const ::abb::egm::wrapper::Quaternion& quaternion() const;
  inline ::abb::egm::wrapper::Quaternion* mutable_quaternion();
  inline ::abb::egm::wrapper::Quaternion* release_quaternion();
  inline void set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianPose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_euler();
  inline void clear_has_euler();
  inline void set_has_quaternion();
  inline void clear_has_quaternion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Cartesian* position_;
  ::abb::egm::wrapper::Euler* euler_;
  ::abb::egm::wrapper::Quaternion* quaternion_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static CartesianPose* default_instance_;
};
// -------------------------------------------------------------------

class CartesianVelocity : public ::google::protobuf::Message {
 public:
  CartesianVelocity();
  virtual ~CartesianVelocity();

  CartesianVelocity(const CartesianVelocity& from);

  inline CartesianVelocity& operator=(const CartesianVelocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianVelocity& default_instance();

  void Swap(CartesianVelocity* other);

  // implements Message ----------------------------------------------

  CartesianVelocity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CartesianVelocity& from);
  void MergeFrom(const CartesianVelocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Cartesian linear = 1;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 1;
  inline const ::abb::egm::wrapper::Cartesian& linear() const;
  inline ::abb::egm::wrapper::Cartesian* mutable_linear();
  inline ::abb::egm::wrapper::Cartesian* release_linear();
  inline void set_allocated_linear(::abb::egm::wrapper::Cartesian* linear);

  // optional .abb.egm.wrapper.Euler angular = 2;
  inline bool has_angular() const;
  inline void clear_angular();
  static const int kAngularFieldNumber = 2;
  inline const ::abb::egm::wrapper::Euler& angular() const;
  inline ::abb::egm::wrapper::Euler* mutable_angular();
  inline ::abb::egm::wrapper::Euler* release_angular();
  inline void set_allocated_angular(::abb::egm::wrapper::Euler* angular);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianVelocity)
 private:
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_angular();
  inline void clear_has_angular();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Cartesian* linear_;
  ::abb::egm::wrapper::Euler* angular_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static CartesianVelocity* default_instance_;
};
// -------------------------------------------------------------------

class CartesianSpace : public ::google::protobuf::Message {
 public:
  CartesianSpace();
  virtual ~CartesianSpace();

  CartesianSpace(const CartesianSpace& from);

  inline CartesianSpace& operator=(const CartesianSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartesianSpace& default_instance();

  void Swap(CartesianSpace* other);

  // implements Message ----------------------------------------------

  CartesianSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CartesianSpace& from);
  void MergeFrom(const CartesianSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 1;
  inline const ::abb::egm::wrapper::CartesianPose& pose() const;
  inline ::abb::egm::wrapper::CartesianPose* mutable_pose();
  inline ::abb::egm::wrapper::CartesianPose* release_pose();
  inline void set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose);

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline const ::abb::egm::wrapper::CartesianVelocity& velocity() const;
  inline ::abb::egm::wrapper::CartesianVelocity* mutable_velocity();
  inline ::abb::egm::wrapper::CartesianVelocity* release_velocity();
  inline void set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.CartesianSpace)
 private:
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::CartesianPose* pose_;
  ::abb::egm::wrapper::CartesianVelocity* velocity_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static CartesianSpace* default_instance_;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  void Swap(Robot* other);

  // implements Message ----------------------------------------------

  Robot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.JointSpace joints = 1;
  inline bool has_joints() const;
  inline void clear_joints();
  static const int kJointsFieldNumber = 1;
  inline const ::abb::egm::wrapper::JointSpace& joints() const;
  inline ::abb::egm::wrapper::JointSpace* mutable_joints();
  inline ::abb::egm::wrapper::JointSpace* release_joints();
  inline void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  inline bool has_cartesian() const;
  inline void clear_cartesian();
  static const int kCartesianFieldNumber = 2;
  inline const ::abb::egm::wrapper::CartesianSpace& cartesian() const;
  inline ::abb::egm::wrapper::CartesianSpace* mutable_cartesian();
  inline ::abb::egm::wrapper::CartesianSpace* release_cartesian();
  inline void set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Robot)
 private:
  inline void set_has_joints();
  inline void clear_has_joints();
  inline void set_has_cartesian();
  inline void clear_has_cartesian();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::JointSpace* joints_;
  ::abb::egm::wrapper::CartesianSpace* cartesian_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Robot* default_instance_;
};
// -------------------------------------------------------------------

class External : public ::google::protobuf::Message {
 public:
  External();
  virtual ~External();

  External(const External& from);

  inline External& operator=(const External& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const External& default_instance();

  void Swap(External* other);

  // implements Message ----------------------------------------------

  External* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const External& from);
  void MergeFrom(const External& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.JointSpace joints = 1;
  inline bool has_joints() const;
  inline void clear_joints();
  static const int kJointsFieldNumber = 1;
  inline const ::abb::egm::wrapper::JointSpace& joints() const;
  inline ::abb::egm::wrapper::JointSpace* mutable_joints();
  inline ::abb::egm::wrapper::JointSpace* release_joints();
  inline void set_allocated_joints(::abb::egm::wrapper::JointSpace* joints);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.External)
 private:
  inline void set_has_joints();
  inline void clear_has_joints();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::JointSpace* joints_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static External* default_instance_;
};
// -------------------------------------------------------------------

class Feedback : public ::google::protobuf::Message {
 public:
  Feedback();
  virtual ~Feedback();

  Feedback(const Feedback& from);

  inline Feedback& operator=(const Feedback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Feedback& default_instance();

  void Swap(Feedback* other);

  // implements Message ----------------------------------------------

  Feedback* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Feedback& from);
  void MergeFrom(const Feedback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Robot robot = 1;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 1;
  inline const ::abb::egm::wrapper::Robot& robot() const;
  inline ::abb::egm::wrapper::Robot* mutable_robot();
  inline ::abb::egm::wrapper::Robot* release_robot();
  inline void set_allocated_robot(::abb::egm::wrapper::Robot* robot);

  // optional .abb.egm.wrapper.External external = 2;
  inline bool has_external() const;
  inline void clear_external();
  static const int kExternalFieldNumber = 2;
  inline const ::abb::egm::wrapper::External& external() const;
  inline ::abb::egm::wrapper::External* mutable_external();
  inline ::abb::egm::wrapper::External* release_external();
  inline void set_allocated_external(::abb::egm::wrapper::External* external);

  // optional .abb.egm.wrapper.Clock time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::abb::egm::wrapper::Clock& time() const;
  inline ::abb::egm::wrapper::Clock* mutable_time();
  inline ::abb::egm::wrapper::Clock* release_time();
  inline void set_allocated_time(::abb::egm::wrapper::Clock* time);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Feedback)
 private:
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_external();
  inline void clear_has_external();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  ::abb::egm::wrapper::Clock* time_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Feedback* default_instance_;
};
// -------------------------------------------------------------------

class Planned : public ::google::protobuf::Message {
 public:
  Planned();
  virtual ~Planned();

  Planned(const Planned& from);

  inline Planned& operator=(const Planned& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Planned& default_instance();

  void Swap(Planned* other);

  // implements Message ----------------------------------------------

  Planned* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Planned& from);
  void MergeFrom(const Planned& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Robot robot = 1;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 1;
  inline const ::abb::egm::wrapper::Robot& robot() const;
  inline ::abb::egm::wrapper::Robot* mutable_robot();
  inline ::abb::egm::wrapper::Robot* release_robot();
  inline void set_allocated_robot(::abb::egm::wrapper::Robot* robot);

  // optional .abb.egm.wrapper.External external = 2;
  inline bool has_external() const;
  inline void clear_external();
  static const int kExternalFieldNumber = 2;
  inline const ::abb::egm::wrapper::External& external() const;
  inline ::abb::egm::wrapper::External* mutable_external();
  inline ::abb::egm::wrapper::External* release_external();
  inline void set_allocated_external(::abb::egm::wrapper::External* external);

  // optional .abb.egm.wrapper.Clock time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::abb::egm::wrapper::Clock& time() const;
  inline ::abb::egm::wrapper::Clock* mutable_time();
  inline ::abb::egm::wrapper::Clock* release_time();
  inline void set_allocated_time(::abb::egm::wrapper::Clock* time);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Planned)
 private:
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_external();
  inline void clear_has_external();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  ::abb::egm::wrapper::Clock* time_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Planned* default_instance_;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  void Swap(Input* other);

  // implements Message ----------------------------------------------

  Input* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::abb::egm::wrapper::Header& header() const;
  inline ::abb::egm::wrapper::Header* mutable_header();
  inline ::abb::egm::wrapper::Header* release_header();
  inline void set_allocated_header(::abb::egm::wrapper::Header* header);

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  inline bool has_feedback() const;
  inline void clear_feedback();
  static const int kFeedbackFieldNumber = 2;
  inline const ::abb::egm::wrapper::Feedback& feedback() const;
  inline ::abb::egm::wrapper::Feedback* mutable_feedback();
  inline ::abb::egm::wrapper::Feedback* release_feedback();
  inline void set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback);

  // optional .abb.egm.wrapper.Planned planned = 3;
  inline bool has_planned() const;
  inline void clear_planned();
  static const int kPlannedFieldNumber = 3;
  inline const ::abb::egm::wrapper::Planned& planned() const;
  inline ::abb::egm::wrapper::Planned* mutable_planned();
  inline ::abb::egm::wrapper::Planned* release_planned();
  inline void set_allocated_planned(::abb::egm::wrapper::Planned* planned);

  // optional .abb.egm.wrapper.Status status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::abb::egm::wrapper::Status& status() const;
  inline ::abb::egm::wrapper::Status* mutable_status();
  inline ::abb::egm::wrapper::Status* release_status();
  inline void set_allocated_status(::abb::egm::wrapper::Status* status);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Input)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_feedback();
  inline void clear_has_feedback();
  inline void set_has_planned();
  inline void clear_has_planned();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Header* header_;
  ::abb::egm::wrapper::Feedback* feedback_;
  ::abb::egm::wrapper::Planned* planned_;
  ::abb::egm::wrapper::Status* status_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Input* default_instance_;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  void Swap(Output* other);

  // implements Message ----------------------------------------------

  Output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .abb.egm.wrapper.Robot robot = 1;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 1;
  inline const ::abb::egm::wrapper::Robot& robot() const;
  inline ::abb::egm::wrapper::Robot* mutable_robot();
  inline ::abb::egm::wrapper::Robot* release_robot();
  inline void set_allocated_robot(::abb::egm::wrapper::Robot* robot);

  // optional .abb.egm.wrapper.External external = 2;
  inline bool has_external() const;
  inline void clear_external();
  static const int kExternalFieldNumber = 2;
  inline const ::abb::egm::wrapper::External& external() const;
  inline ::abb::egm::wrapper::External* mutable_external();
  inline ::abb::egm::wrapper::External* release_external();
  inline void set_allocated_external(::abb::egm::wrapper::External* external);

  // @@protoc_insertion_point(class_scope:abb.egm.wrapper.Output)
 private:
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_external();
  inline void clear_has_external();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::abb::egm::wrapper::Robot* robot_;
  ::abb::egm::wrapper::External* external_;
  friend void  protobuf_AddDesc_egm_5fwrapper_2eproto();
  friend void protobuf_AssignDesc_egm_5fwrapper_2eproto();
  friend void protobuf_ShutdownFile_egm_5fwrapper_2eproto();

  void InitAsDefaultInstance();
  static Output* default_instance_;
};
// ===================================================================


// ===================================================================

// Header

// optional uint32 sequence_number = 1;
inline bool Header::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_sequence_number() {
  sequence_number_ = 0u;
  clear_has_sequence_number();
}
inline ::google::protobuf::uint32 Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.sequence_number)
  return sequence_number_;
}
inline void Header::set_sequence_number(::google::protobuf::uint32 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.sequence_number)
}

// optional uint32 time_stamp = 2;
inline bool Header::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.time_stamp)
  return time_stamp_;
}
inline void Header::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.time_stamp)
}

// optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
inline bool Header::has_message_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_message_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::abb::egm::wrapper::Header_MessageType Header::message_type() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Header.message_type)
  return static_cast< ::abb::egm::wrapper::Header_MessageType >(message_type_);
}
inline void Header::set_message_type(::abb::egm::wrapper::Header_MessageType value) {
  assert(::abb::egm::wrapper::Header_MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Header.message_type)
}

// -------------------------------------------------------------------

// Status

// optional bool egm_convergence_met = 1;
inline bool Status::has_egm_convergence_met() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_egm_convergence_met() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_egm_convergence_met() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_egm_convergence_met() {
  egm_convergence_met_ = false;
  clear_has_egm_convergence_met();
}
inline bool Status::egm_convergence_met() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_convergence_met)
  return egm_convergence_met_;
}
inline void Status::set_egm_convergence_met(bool value) {
  set_has_egm_convergence_met();
  egm_convergence_met_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_convergence_met)
}

// optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
inline bool Status::has_egm_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_egm_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_egm_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_egm_state() {
  egm_state_ = 0;
  clear_has_egm_state();
}
inline ::abb::egm::wrapper::Status_EGMState Status::egm_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.egm_state)
  return static_cast< ::abb::egm::wrapper::Status_EGMState >(egm_state_);
}
inline void Status::set_egm_state(::abb::egm::wrapper::Status_EGMState value) {
  assert(::abb::egm::wrapper::Status_EGMState_IsValid(value));
  set_has_egm_state();
  egm_state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.egm_state)
}

// optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
inline bool Status::has_motor_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_motor_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_motor_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_motor_state() {
  motor_state_ = 0;
  clear_has_motor_state();
}
inline ::abb::egm::wrapper::Status_MotorState Status::motor_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.motor_state)
  return static_cast< ::abb::egm::wrapper::Status_MotorState >(motor_state_);
}
inline void Status::set_motor_state(::abb::egm::wrapper::Status_MotorState value) {
  assert(::abb::egm::wrapper::Status_MotorState_IsValid(value));
  set_has_motor_state();
  motor_state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.motor_state)
}

// optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
inline bool Status::has_rapid_execution_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Status::set_has_rapid_execution_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Status::clear_has_rapid_execution_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Status::clear_rapid_execution_state() {
  rapid_execution_state_ = 0;
  clear_has_rapid_execution_state();
}
inline ::abb::egm::wrapper::Status_RAPIDExecutionState Status::rapid_execution_state() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Status.rapid_execution_state)
  return static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(rapid_execution_state_);
}
inline void Status::set_rapid_execution_state(::abb::egm::wrapper::Status_RAPIDExecutionState value) {
  assert(::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value));
  set_has_rapid_execution_state();
  rapid_execution_state_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Status.rapid_execution_state)
}

// -------------------------------------------------------------------

// Clock

// optional uint64 sec = 1;
inline bool Clock::has_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clock::set_has_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clock::clear_has_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clock::clear_sec() {
  sec_ = GOOGLE_ULONGLONG(0);
  clear_has_sec();
}
inline ::google::protobuf::uint64 Clock::sec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.sec)
  return sec_;
}
inline void Clock::set_sec(::google::protobuf::uint64 value) {
  set_has_sec();
  sec_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.sec)
}

// optional uint64 usec = 2;
inline bool Clock::has_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clock::set_has_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clock::clear_has_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clock::clear_usec() {
  usec_ = GOOGLE_ULONGLONG(0);
  clear_has_usec();
}
inline ::google::protobuf::uint64 Clock::usec() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Clock.usec)
  return usec_;
}
inline void Clock::set_usec(::google::protobuf::uint64 value) {
  set_has_usec();
  usec_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Clock.usec)
}

// -------------------------------------------------------------------

// Joints

// repeated double values = 1;
inline int Joints::values_size() const {
  return values_.size();
}
inline void Joints::clear_values() {
  values_.Clear();
}
inline double Joints::values(int index) const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Joints.values)
  return values_.Get(index);
}
inline void Joints::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Joints.values)
}
inline void Joints::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:abb.egm.wrapper.Joints.values)
}
inline const ::google::protobuf::RepeatedField< double >&
Joints::values() const {
  // @@protoc_insertion_point(field_list:abb.egm.wrapper.Joints.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
Joints::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:abb.egm.wrapper.Joints.values)
  return &values_;
}

// -------------------------------------------------------------------

// JointSpace

// optional .abb.egm.wrapper.Joints position = 1;
inline bool JointSpace::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointSpace::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointSpace::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointSpace::clear_position() {
  if (position_ != NULL) position_->::abb::egm::wrapper::Joints::Clear();
  clear_has_position();
}
inline const ::abb::egm::wrapper::Joints& JointSpace::position() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::abb::egm::wrapper::Joints;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.position)
  return position_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_position() {
  clear_has_position();
  ::abb::egm::wrapper::Joints* temp = position_;
  position_ = NULL;
  return temp;
}
inline void JointSpace::set_allocated_position(::abb::egm::wrapper::Joints* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.position)
}

// optional .abb.egm.wrapper.Joints velocity = 2;
inline bool JointSpace::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointSpace::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointSpace::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointSpace::clear_velocity() {
  if (velocity_ != NULL) velocity_->::abb::egm::wrapper::Joints::Clear();
  clear_has_velocity();
}
inline const ::abb::egm::wrapper::Joints& JointSpace::velocity() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.JointSpace.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::abb::egm::wrapper::Joints;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.JointSpace.velocity)
  return velocity_;
}
inline ::abb::egm::wrapper::Joints* JointSpace::release_velocity() {
  clear_has_velocity();
  ::abb::egm::wrapper::Joints* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void JointSpace::set_allocated_velocity(::abb::egm::wrapper::Joints* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.JointSpace.velocity)
}

// -------------------------------------------------------------------

// Cartesian

// optional double x = 1;
inline bool Cartesian::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cartesian::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cartesian::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cartesian::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Cartesian::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.x)
  return x_;
}
inline void Cartesian::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.x)
}

// optional double y = 2;
inline bool Cartesian::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cartesian::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cartesian::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cartesian::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Cartesian::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.y)
  return y_;
}
inline void Cartesian::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.y)
}

// optional double z = 3;
inline bool Cartesian::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cartesian::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cartesian::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cartesian::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Cartesian::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Cartesian.z)
  return z_;
}
inline void Cartesian::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Cartesian.z)
}

// -------------------------------------------------------------------

// Euler

// optional double x = 1;
inline bool Euler::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Euler::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Euler::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Euler::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Euler::x() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.x)
  return x_;
}
inline void Euler::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.x)
}

// optional double y = 2;
inline bool Euler::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Euler::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Euler::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Euler::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Euler::y() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.y)
  return y_;
}
inline void Euler::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.y)
}

// optional double z = 3;
inline bool Euler::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Euler::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Euler::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Euler::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Euler::z() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Euler.z)
  return z_;
}
inline void Euler::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Euler.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double u0 = 1;
inline bool Quaternion::has_u0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_u0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_u0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_u0() {
  u0_ = 0;
  clear_has_u0();
}
inline double Quaternion::u0() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u0)
  return u0_;
}
inline void Quaternion::set_u0(double value) {
  set_has_u0();
  u0_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u0)
}

// optional double u1 = 2;
inline bool Quaternion::has_u1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_u1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_u1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_u1() {
  u1_ = 0;
  clear_has_u1();
}
inline double Quaternion::u1() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u1)
  return u1_;
}
inline void Quaternion::set_u1(double value) {
  set_has_u1();
  u1_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u1)
}

// optional double u2 = 3;
inline bool Quaternion::has_u2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_u2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_u2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_u2() {
  u2_ = 0;
  clear_has_u2();
}
inline double Quaternion::u2() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u2)
  return u2_;
}
inline void Quaternion::set_u2(double value) {
  set_has_u2();
  u2_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u2)
}

// optional double u3 = 4;
inline bool Quaternion::has_u3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_u3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_u3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_u3() {
  u3_ = 0;
  clear_has_u3();
}
inline double Quaternion::u3() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Quaternion.u3)
  return u3_;
}
inline void Quaternion::set_u3(double value) {
  set_has_u3();
  u3_ = value;
  // @@protoc_insertion_point(field_set:abb.egm.wrapper.Quaternion.u3)
}

// -------------------------------------------------------------------

// CartesianPose

// optional .abb.egm.wrapper.Cartesian position = 1;
inline bool CartesianPose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianPose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianPose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianPose::clear_position() {
  if (position_ != NULL) position_->::abb::egm::wrapper::Cartesian::Clear();
  clear_has_position();
}
inline const ::abb::egm::wrapper::Cartesian& CartesianPose::position() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::abb::egm::wrapper::Cartesian;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.position)
  return position_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianPose::release_position() {
  clear_has_position();
  ::abb::egm::wrapper::Cartesian* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CartesianPose::set_allocated_position(::abb::egm::wrapper::Cartesian* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.position)
}

// optional .abb.egm.wrapper.Euler euler = 2;
inline bool CartesianPose::has_euler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianPose::set_has_euler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianPose::clear_has_euler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianPose::clear_euler() {
  if (euler_ != NULL) euler_->::abb::egm::wrapper::Euler::Clear();
  clear_has_euler();
}
inline const ::abb::egm::wrapper::Euler& CartesianPose::euler() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.euler)
  return euler_ != NULL ? *euler_ : *default_instance_->euler_;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::mutable_euler() {
  set_has_euler();
  if (euler_ == NULL) euler_ = new ::abb::egm::wrapper::Euler;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.euler)
  return euler_;
}
inline ::abb::egm::wrapper::Euler* CartesianPose::release_euler() {
  clear_has_euler();
  ::abb::egm::wrapper::Euler* temp = euler_;
  euler_ = NULL;
  return temp;
}
inline void CartesianPose::set_allocated_euler(::abb::egm::wrapper::Euler* euler) {
  delete euler_;
  euler_ = euler;
  if (euler) {
    set_has_euler();
  } else {
    clear_has_euler();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.euler)
}

// optional .abb.egm.wrapper.Quaternion quaternion = 3;
inline bool CartesianPose::has_quaternion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CartesianPose::set_has_quaternion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CartesianPose::clear_has_quaternion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CartesianPose::clear_quaternion() {
  if (quaternion_ != NULL) quaternion_->::abb::egm::wrapper::Quaternion::Clear();
  clear_has_quaternion();
}
inline const ::abb::egm::wrapper::Quaternion& CartesianPose::quaternion() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianPose.quaternion)
  return quaternion_ != NULL ? *quaternion_ : *default_instance_->quaternion_;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::mutable_quaternion() {
  set_has_quaternion();
  if (quaternion_ == NULL) quaternion_ = new ::abb::egm::wrapper::Quaternion;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianPose.quaternion)
  return quaternion_;
}
inline ::abb::egm::wrapper::Quaternion* CartesianPose::release_quaternion() {
  clear_has_quaternion();
  ::abb::egm::wrapper::Quaternion* temp = quaternion_;
  quaternion_ = NULL;
  return temp;
}
inline void CartesianPose::set_allocated_quaternion(::abb::egm::wrapper::Quaternion* quaternion) {
  delete quaternion_;
  quaternion_ = quaternion;
  if (quaternion) {
    set_has_quaternion();
  } else {
    clear_has_quaternion();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianPose.quaternion)
}

// -------------------------------------------------------------------

// CartesianVelocity

// optional .abb.egm.wrapper.Cartesian linear = 1;
inline bool CartesianVelocity::has_linear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianVelocity::set_has_linear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianVelocity::clear_has_linear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianVelocity::clear_linear() {
  if (linear_ != NULL) linear_->::abb::egm::wrapper::Cartesian::Clear();
  clear_has_linear();
}
inline const ::abb::egm::wrapper::Cartesian& CartesianVelocity::linear() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.linear)
  return linear_ != NULL ? *linear_ : *default_instance_->linear_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::mutable_linear() {
  set_has_linear();
  if (linear_ == NULL) linear_ = new ::abb::egm::wrapper::Cartesian;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.linear)
  return linear_;
}
inline ::abb::egm::wrapper::Cartesian* CartesianVelocity::release_linear() {
  clear_has_linear();
  ::abb::egm::wrapper::Cartesian* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline void CartesianVelocity::set_allocated_linear(::abb::egm::wrapper::Cartesian* linear) {
  delete linear_;
  linear_ = linear;
  if (linear) {
    set_has_linear();
  } else {
    clear_has_linear();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.linear)
}

// optional .abb.egm.wrapper.Euler angular = 2;
inline bool CartesianVelocity::has_angular() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianVelocity::set_has_angular() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianVelocity::clear_has_angular() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianVelocity::clear_angular() {
  if (angular_ != NULL) angular_->::abb::egm::wrapper::Euler::Clear();
  clear_has_angular();
}
inline const ::abb::egm::wrapper::Euler& CartesianVelocity::angular() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianVelocity.angular)
  return angular_ != NULL ? *angular_ : *default_instance_->angular_;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::mutable_angular() {
  set_has_angular();
  if (angular_ == NULL) angular_ = new ::abb::egm::wrapper::Euler;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianVelocity.angular)
  return angular_;
}
inline ::abb::egm::wrapper::Euler* CartesianVelocity::release_angular() {
  clear_has_angular();
  ::abb::egm::wrapper::Euler* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline void CartesianVelocity::set_allocated_angular(::abb::egm::wrapper::Euler* angular) {
  delete angular_;
  angular_ = angular;
  if (angular) {
    set_has_angular();
  } else {
    clear_has_angular();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianVelocity.angular)
}

// -------------------------------------------------------------------

// CartesianSpace

// optional .abb.egm.wrapper.CartesianPose pose = 1;
inline bool CartesianSpace::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartesianSpace::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartesianSpace::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartesianSpace::clear_pose() {
  if (pose_ != NULL) pose_->::abb::egm::wrapper::CartesianPose::Clear();
  clear_has_pose();
}
inline const ::abb::egm::wrapper::CartesianPose& CartesianSpace::pose() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::abb::egm::wrapper::CartesianPose;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.pose)
  return pose_;
}
inline ::abb::egm::wrapper::CartesianPose* CartesianSpace::release_pose() {
  clear_has_pose();
  ::abb::egm::wrapper::CartesianPose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void CartesianSpace::set_allocated_pose(::abb::egm::wrapper::CartesianPose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.pose)
}

// optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
inline bool CartesianSpace::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartesianSpace::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartesianSpace::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartesianSpace::clear_velocity() {
  if (velocity_ != NULL) velocity_->::abb::egm::wrapper::CartesianVelocity::Clear();
  clear_has_velocity();
}
inline const ::abb::egm::wrapper::CartesianVelocity& CartesianSpace::velocity() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.CartesianSpace.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::abb::egm::wrapper::CartesianVelocity;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.CartesianSpace.velocity)
  return velocity_;
}
inline ::abb::egm::wrapper::CartesianVelocity* CartesianSpace::release_velocity() {
  clear_has_velocity();
  ::abb::egm::wrapper::CartesianVelocity* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void CartesianSpace::set_allocated_velocity(::abb::egm::wrapper::CartesianVelocity* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.CartesianSpace.velocity)
}

// -------------------------------------------------------------------

// Robot

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool Robot::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_joints() {
  if (joints_ != NULL) joints_->::abb::egm::wrapper::JointSpace::Clear();
  clear_has_joints();
}
inline const ::abb::egm::wrapper::JointSpace& Robot::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.joints)
  return joints_ != NULL ? *joints_ : *default_instance_->joints_;
}
inline ::abb::egm::wrapper::JointSpace* Robot::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) joints_ = new ::abb::egm::wrapper::JointSpace;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.joints)
  return joints_;
}
inline ::abb::egm::wrapper::JointSpace* Robot::release_joints() {
  clear_has_joints();
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void Robot::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.joints)
}

// optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
inline bool Robot::has_cartesian() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_cartesian() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_cartesian() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_cartesian() {
  if (cartesian_ != NULL) cartesian_->::abb::egm::wrapper::CartesianSpace::Clear();
  clear_has_cartesian();
}
inline const ::abb::egm::wrapper::CartesianSpace& Robot::cartesian() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Robot.cartesian)
  return cartesian_ != NULL ? *cartesian_ : *default_instance_->cartesian_;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::mutable_cartesian() {
  set_has_cartesian();
  if (cartesian_ == NULL) cartesian_ = new ::abb::egm::wrapper::CartesianSpace;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Robot.cartesian)
  return cartesian_;
}
inline ::abb::egm::wrapper::CartesianSpace* Robot::release_cartesian() {
  clear_has_cartesian();
  ::abb::egm::wrapper::CartesianSpace* temp = cartesian_;
  cartesian_ = NULL;
  return temp;
}
inline void Robot::set_allocated_cartesian(::abb::egm::wrapper::CartesianSpace* cartesian) {
  delete cartesian_;
  cartesian_ = cartesian;
  if (cartesian) {
    set_has_cartesian();
  } else {
    clear_has_cartesian();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Robot.cartesian)
}

// -------------------------------------------------------------------

// External

// optional .abb.egm.wrapper.JointSpace joints = 1;
inline bool External::has_joints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void External::set_has_joints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void External::clear_has_joints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void External::clear_joints() {
  if (joints_ != NULL) joints_->::abb::egm::wrapper::JointSpace::Clear();
  clear_has_joints();
}
inline const ::abb::egm::wrapper::JointSpace& External::joints() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.External.joints)
  return joints_ != NULL ? *joints_ : *default_instance_->joints_;
}
inline ::abb::egm::wrapper::JointSpace* External::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) joints_ = new ::abb::egm::wrapper::JointSpace;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.External.joints)
  return joints_;
}
inline ::abb::egm::wrapper::JointSpace* External::release_joints() {
  clear_has_joints();
  ::abb::egm::wrapper::JointSpace* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void External::set_allocated_joints(::abb::egm::wrapper::JointSpace* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.External.joints)
}

// -------------------------------------------------------------------

// Feedback

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Feedback::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Feedback::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Feedback::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Feedback::clear_robot() {
  if (robot_ != NULL) robot_->::abb::egm::wrapper::Robot::Clear();
  clear_has_robot();
}
inline const ::abb::egm::wrapper::Robot& Feedback::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::abb::egm::wrapper::Robot* Feedback::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) robot_ = new ::abb::egm::wrapper::Robot;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.robot)
  return robot_;
}
inline ::abb::egm::wrapper::Robot* Feedback::release_robot() {
  clear_has_robot();
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Feedback::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Feedback::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Feedback::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Feedback::clear_external() {
  if (external_ != NULL) external_->::abb::egm::wrapper::External::Clear();
  clear_has_external();
}
inline const ::abb::egm::wrapper::External& Feedback::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.external)
  return external_ != NULL ? *external_ : *default_instance_->external_;
}
inline ::abb::egm::wrapper::External* Feedback::mutable_external() {
  set_has_external();
  if (external_ == NULL) external_ = new ::abb::egm::wrapper::External;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.external)
  return external_;
}
inline ::abb::egm::wrapper::External* Feedback::release_external() {
  clear_has_external();
  ::abb::egm::wrapper::External* temp = external_;
  external_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_external(::abb::egm::wrapper::External* external) {
  delete external_;
  external_ = external;
  if (external) {
    set_has_external();
  } else {
    clear_has_external();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Feedback::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Feedback::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Feedback::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Feedback::clear_time() {
  if (time_ != NULL) time_->::abb::egm::wrapper::Clock::Clear();
  clear_has_time();
}
inline const ::abb::egm::wrapper::Clock& Feedback::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Feedback.time)
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::abb::egm::wrapper::Clock* Feedback::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::abb::egm::wrapper::Clock;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Feedback.time)
  return time_;
}
inline ::abb::egm::wrapper::Clock* Feedback::release_time() {
  clear_has_time();
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Feedback::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Feedback.time)
}

// -------------------------------------------------------------------

// Planned

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Planned::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Planned::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Planned::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Planned::clear_robot() {
  if (robot_ != NULL) robot_->::abb::egm::wrapper::Robot::Clear();
  clear_has_robot();
}
inline const ::abb::egm::wrapper::Robot& Planned::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::abb::egm::wrapper::Robot* Planned::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) robot_ = new ::abb::egm::wrapper::Robot;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.robot)
  return robot_;
}
inline ::abb::egm::wrapper::Robot* Planned::release_robot() {
  clear_has_robot();
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Planned::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Planned::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Planned::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Planned::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Planned::clear_external() {
  if (external_ != NULL) external_->::abb::egm::wrapper::External::Clear();
  clear_has_external();
}
inline const ::abb::egm::wrapper::External& Planned::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.external)
  return external_ != NULL ? *external_ : *default_instance_->external_;
}
inline ::abb::egm::wrapper::External* Planned::mutable_external() {
  set_has_external();
  if (external_ == NULL) external_ = new ::abb::egm::wrapper::External;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.external)
  return external_;
}
inline ::abb::egm::wrapper::External* Planned::release_external() {
  clear_has_external();
  ::abb::egm::wrapper::External* temp = external_;
  external_ = NULL;
  return temp;
}
inline void Planned::set_allocated_external(::abb::egm::wrapper::External* external) {
  delete external_;
  external_ = external;
  if (external) {
    set_has_external();
  } else {
    clear_has_external();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.external)
}

// optional .abb.egm.wrapper.Clock time = 3;
inline bool Planned::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Planned::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Planned::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Planned::clear_time() {
  if (time_ != NULL) time_->::abb::egm::wrapper::Clock::Clear();
  clear_has_time();
}
inline const ::abb::egm::wrapper::Clock& Planned::time() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Planned.time)
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::abb::egm::wrapper::Clock* Planned::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::abb::egm::wrapper::Clock;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Planned.time)
  return time_;
}
inline ::abb::egm::wrapper::Clock* Planned::release_time() {
  clear_has_time();
  ::abb::egm::wrapper::Clock* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Planned::set_allocated_time(::abb::egm::wrapper::Clock* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Planned.time)
}

// -------------------------------------------------------------------

// Input

// optional .abb.egm.wrapper.Header header = 1;
inline bool Input::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_header() {
  if (header_ != NULL) header_->::abb::egm::wrapper::Header::Clear();
  clear_has_header();
}
inline const ::abb::egm::wrapper::Header& Input::header() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::abb::egm::wrapper::Header* Input::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::abb::egm::wrapper::Header;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.header)
  return header_;
}
inline ::abb::egm::wrapper::Header* Input::release_header() {
  clear_has_header();
  ::abb::egm::wrapper::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Input::set_allocated_header(::abb::egm::wrapper::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.header)
}

// optional .abb.egm.wrapper.Feedback feedback = 2;
inline bool Input::has_feedback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_feedback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_feedback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_feedback() {
  if (feedback_ != NULL) feedback_->::abb::egm::wrapper::Feedback::Clear();
  clear_has_feedback();
}
inline const ::abb::egm::wrapper::Feedback& Input::feedback() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.feedback)
  return feedback_ != NULL ? *feedback_ : *default_instance_->feedback_;
}
inline ::abb::egm::wrapper::Feedback* Input::mutable_feedback() {
  set_has_feedback();
  if (feedback_ == NULL) feedback_ = new ::abb::egm::wrapper::Feedback;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.feedback)
  return feedback_;
}
inline ::abb::egm::wrapper::Feedback* Input::release_feedback() {
  clear_has_feedback();
  ::abb::egm::wrapper::Feedback* temp = feedback_;
  feedback_ = NULL;
  return temp;
}
inline void Input::set_allocated_feedback(::abb::egm::wrapper::Feedback* feedback) {
  delete feedback_;
  feedback_ = feedback;
  if (feedback) {
    set_has_feedback();
  } else {
    clear_has_feedback();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.feedback)
}

// optional .abb.egm.wrapper.Planned planned = 3;
inline bool Input::has_planned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_planned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_planned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input::clear_planned() {
  if (planned_ != NULL) planned_->::abb::egm::wrapper::Planned::Clear();
  clear_has_planned();
}
inline const ::abb::egm::wrapper::Planned& Input::planned() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.planned)
  return planned_ != NULL ? *planned_ : *default_instance_->planned_;
}
inline ::abb::egm::wrapper::Planned* Input::mutable_planned() {
  set_has_planned();
  if (planned_ == NULL) planned_ = new ::abb::egm::wrapper::Planned;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.planned)
  return planned_;
}
inline ::abb::egm::wrapper::Planned* Input::release_planned() {
  clear_has_planned();
  ::abb::egm::wrapper::Planned* temp = planned_;
  planned_ = NULL;
  return temp;
}
inline void Input::set_allocated_planned(::abb::egm::wrapper::Planned* planned) {
  delete planned_;
  planned_ = planned;
  if (planned) {
    set_has_planned();
  } else {
    clear_has_planned();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.planned)
}

// optional .abb.egm.wrapper.Status status = 4;
inline bool Input::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input::clear_status() {
  if (status_ != NULL) status_->::abb::egm::wrapper::Status::Clear();
  clear_has_status();
}
inline const ::abb::egm::wrapper::Status& Input::status() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Input.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::abb::egm::wrapper::Status* Input::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::abb::egm::wrapper::Status;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Input.status)
  return status_;
}
inline ::abb::egm::wrapper::Status* Input::release_status() {
  clear_has_status();
  ::abb::egm::wrapper::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Input::set_allocated_status(::abb::egm::wrapper::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Input.status)
}

// -------------------------------------------------------------------

// Output

// optional .abb.egm.wrapper.Robot robot = 1;
inline bool Output::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_robot() {
  if (robot_ != NULL) robot_->::abb::egm::wrapper::Robot::Clear();
  clear_has_robot();
}
inline const ::abb::egm::wrapper::Robot& Output::robot() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.robot)
  return robot_ != NULL ? *robot_ : *default_instance_->robot_;
}
inline ::abb::egm::wrapper::Robot* Output::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) robot_ = new ::abb::egm::wrapper::Robot;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.robot)
  return robot_;
}
inline ::abb::egm::wrapper::Robot* Output::release_robot() {
  clear_has_robot();
  ::abb::egm::wrapper::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline void Output::set_allocated_robot(::abb::egm::wrapper::Robot* robot) {
  delete robot_;
  robot_ = robot;
  if (robot) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.robot)
}

// optional .abb.egm.wrapper.External external = 2;
inline bool Output::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_external() {
  if (external_ != NULL) external_->::abb::egm::wrapper::External::Clear();
  clear_has_external();
}
inline const ::abb::egm::wrapper::External& Output::external() const {
  // @@protoc_insertion_point(field_get:abb.egm.wrapper.Output.external)
  return external_ != NULL ? *external_ : *default_instance_->external_;
}
inline ::abb::egm::wrapper::External* Output::mutable_external() {
  set_has_external();
  if (external_ == NULL) external_ = new ::abb::egm::wrapper::External;
  // @@protoc_insertion_point(field_mutable:abb.egm.wrapper.Output.external)
  return external_;
}
inline ::abb::egm::wrapper::External* Output::release_external() {
  clear_has_external();
  ::abb::egm::wrapper::External* temp = external_;
  external_ = NULL;
  return temp;
}
inline void Output::set_allocated_external(::abb::egm::wrapper::External* external) {
  delete external_;
  external_ = external;
  if (external) {
    set_has_external();
  } else {
    clear_has_external();
  }
  // @@protoc_insertion_point(field_set_allocated:abb.egm.wrapper.Output.external)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wrapper
}  // namespace egm
}  // namespace abb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::abb::egm::wrapper::Header_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Header_MessageType>() {
  return ::abb::egm::wrapper::Header_MessageType_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_EGMState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_EGMState>() {
  return ::abb::egm::wrapper::Status_EGMState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_MotorState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_MotorState>() {
  return ::abb::egm::wrapper::Status_MotorState_descriptor();
}
template <> struct is_proto_enum< ::abb::egm::wrapper::Status_RAPIDExecutionState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abb::egm::wrapper::Status_RAPIDExecutionState>() {
  return ::abb::egm::wrapper::Status_RAPIDExecutionState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_egm_5fwrapper_2eproto__INCLUDED
